{"componentChunkName":"component---src-templates-post-jsx","path":"/spring-core-container/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"markdownRemark":{"id":"d3f01e89-0b7e-5518-b223-4f91816fe1fb","excerpt":"What is Light-Weight Container? 애플리케이션 코드가 실행되는 프레임워크를 의미한다. 애플리케이션 객체(대부분 비즈니스 객체)는 컨테이너 내부에서 실행되며 컨테이너에 의해 관리된다고 한다. 다음은 경량 컨테이너가 가지는 특징들이다. 비침투성 (Non-invasiveness): 이는 애플리케이션 코드에 특별한 의존성을 부과하지 않는 …","html":"<h2 id=\"What-is-Light-Weight-Container\" style=\"position:relative;\">What is Light-Weight Container?<a href=\"#What-is-Light-Weight-Container\" aria-label=\"What is Light Weight Container permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>애플리케이션 코드가 실행되는 프레임워크를 의미한다. 애플리케이션 객체(대부분 비즈니스 객체)는 컨테이너 내부에서 실행되며 컨테이너에 의해 관리된다고 한다. 다음은 경량 컨테이너가 가지는 특징들이다.</p>\n<ul>\n<li>비침투성 (Non-invasiveness): 이는 애플리케이션 코드에 특별한 의존성을 부과하지 않는 컨테이너를 의미한다. 예를 들어, 기존의 코드를 수정하지 않고도 컨테이너 내에서 실행할 수 있어야 한다. 이는 인프라가 애플리케이션 코드에 불필요한 의존성을 부과하지 않아야 함을 의미한다.</li>\n<li>빠른 시작: 컨테이너는 빠르게 시작되어야 한다. 이는 개발 및 배포 시간을 줄이고, 사용자에게 빠른 응답 시간을 제공한다..</li>\n<li>특별한 배포 단계 불필요: 컨테이너 내의 객체를 배포할 때 특별한 단계나 복잡한 설정 없이 쉽게 배포할 수 있어야 한다.</li>\n<li>다양한 환경에서의 실행: 컨테이너는 그 크기와 API 의존성이 최소화되어 다양한 환경에서 실행될 수 있어야 한다. 예를 들면 웹 컨테이너, 독립 실행형 클라이언트, 아니면 애플릿에서도 실행될 수 있어야 한다.</li>\n<li>관리 객체 추가의 낮은 장벽: 컨테이너는 객체를 배포하고 관리하는 데 있어서 노력과 성능 오버헤드가 최소화되어야 한다. 이는 세밀한 객체뿐만 아니라 대형 컴포넌트도 쉽게 배포하고 관리할 수 있어야 함을 의미한다.</li>\n</ul>\n<h2 id=\"Container-Benefits\" style=\"position:relative;\">Container Benefits<a href=\"#Container-Benefits\" aria-label=\"Container Benefits permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>Pluggability: 컨테이너는 다양한 컴포넌트의 플러그 가능성을 제공한다. 예를 들면, 동일한 컴포넌트 인터페이스에 대해 다른 EJB 구현 클래스를 사용할 수 있다. 이렇게 하면 호출 코드가 구현 전략에서 격리된다. 자바 인터페이스는 완벽한 분리를 제공하지만, 어떤 인터페이스의 구현을 사용할 것인지 결정하는 방법이 필요하다. 자바 코드에 하드코딩하면 인터페이스를 사용하는 많은 이점이 사라진다.</li>\n<li>Consistency: 컨테이너 인프라가 없으면 서비스 조회가 불규칙적이게 된다. 다른 서비스 객체는 개발자의 선호에 따라 다르게 위치할 수 있다. 구성 관리도 마찬가지로 불규칙적이게 돼서 지속적인 유지 관리 문제를 초래할 수 있다.</li>\n<li>One stop shop: 컨테이너만 찾으면 그 안의 모든 서비스를 찾을 수 있다. 모든 객체에 대해 전용 싱글톤이나 팩토리가 필요 없다.</li>\n<li>Delivery of enterprise services: 일관된 접근 방식을 사용하면 컨테이너 모델의 일부로, 또는 추가 기능으로 엔터프라이즈 서비스를 제공하는 것이 더 쉬워진다.</li>\n</ul>\n<h2 id=\"Inversion-Of-Control\" style=\"position:relative;\">Inversion Of Control<a href=\"#Inversion-Of-Control\" aria-label=\"Inversion Of Control permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>애플리케이션 코드가 컨테이너에 의존하는 것을 피하는 것이 좋다고 언급했다. 그런데 이게 어떻게 가능할까? 대부분의 비즈니스 객체는 다른 비즈니스 객체, 데이터 접근 객체, 리소스와 같은 의존성을 가진다. 그럼 객체들이 다른 관리 객체나 리소스를 찾아야 하고, 그러한 조회를 만족시킬 수 있는 컨테이너에 의존해야 하지 않을까? 컨테이너에 의존성을 도입하지 않고 의존성을 만족시키는 것은 제어의 역전(Inversion of Control)과 의존성 주입(Dependency Injection)의 마법을 통해 대부분 가능하다.</p>\n<p>제어의 역전은 프레임워크에서 중요한 개념이다. 이는 \"Don’t call us, we’ll call you.\" 라는 할리우드 원칙을 통해 가장 잘 이해된다.</p>\n<p>의존성 주입은 제어의 역전을 사용하여 모든 조회 코드를 제거하고, 컨테이너가 언어 수준에서 표현된 의존성을 자동으로 해결하게 한다.</p>\n<h2 id=\"Dependency-Injection\" style=\"position:relative;\">Dependency Injection<a href=\"#Dependency-Injection\" aria-label=\"Dependency Injection permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>이 방법은 컨테이너에게 의존성 조회를 완전히 맡기고, 관리되는 객체가 JavaBean setter 메서드나 생성자 인수를 통해 초기화될 때 의존성이 그 안으로 전달될 수 있게 하는 것이다.</p>\n<p>이것을 언어 기반의 IoC라고 부른다. 왜냐하면 특별한 컨테이너 API나 인터페이스에 의존하지 않기 때문이다. 의존성 주입을 사용하면 IoC 컨테이너가 모든 연결 작업을 처리한다. 컨테이너는 리소스를 찾는 것을 담당하고, 비즈니스 객체에 필요한 리소스를 제공한다. 애플리케이션 코드에 영향을 주지 않고 필요한 리소스를 얻기 위한 다른 접근 방식을 사용하도록 컨테이너를 재구성할 수 있다.</p>\n<p>의존성 주입 방식은 여러 가지 장점을 제공한다.</p>\n<ul>\n<li>애플리케이션 코드에서 리소스나 다른 객체를 찾기 위한 코드(lookup)가 완전히 제거된다. 이는 코드를 더 깔끔하게 만들어 준다.</li>\n<li>컨테이너 API에 대한 의존성 없어 순수한 자바 언어 개념만을 다룰 수 있다.</li>\n<li>의존성 주입을 위해 특별한 인터페이스를 구현할 필요가 없다.</li>\n</ul>\n<h2 id=\"Spring-IoC-Container\" style=\"position:relative;\">Spring IoC Container<a href=\"#Spring-IoC-Container\" aria-label=\"Spring IoC Container permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>스프링의 기본적인 경량 컨테이너 인터페이스는 BeanFactory 이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">BeanFactory</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">Object</span> <span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">Object</span> <span class=\"token function\">getBean</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span> requiredType<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">boolean</span> <span class=\"token function\">containsBean</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">boolean</span> <span class=\"token function\">isSingleton</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">NoSuchBeanDefinitionException</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getAliases</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">NoSuchBeanDefinitionException</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>BeanFactory 인터페이스는 문자열 이름으로 빈 인스턴스를 조회하기 위한 getBean 메서드를 제공한다.</p>\n<p>BeanFactory는 계층 구조의 일부일 수 있는데, 특정 팩토리에서 bean을 찾을 수 없으면 부모 팩토리에게 요청된다. 이렇게 해서 최상위 팩토리까지 찾게 된다. 상위 컨텍스트의 bean 정의는 하위 컨텍스트에서 볼 수 있지만 반대는 아니다.</p>\n<p>BeanFactory 인터페이스의 대부분의 구현은 이름별로 객체를 등록하는 것뿐만 아니라 그 객체들을 IoC를 사용하여 구성하는 데 풍부한 지원을 제공한다. 예를 들어, 관리되는 객체 간의 의존성과 간단한 속성을 관리한다.</p>\n<p>아래는 BeanFactory 인터페이스를 확장한 ListableBeanFactory 인터페이스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ListableBeanFactory</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">BeanFactory</span> <span class=\"token punctuation\">{</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getBeanDefinitionCount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getBeanDefinitionNames</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token function\">getBeanDefinitionNames</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span> type<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token keyword\">boolean</span> <span class=\"token function\">containsBeanDefinition</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">Map</span> <span class=\"token function\">getBeansOfType</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Class</span> type<span class=\"token punctuation\">,</span> <span class=\"token keyword\">boolean</span> includePrototypes<span class=\"token punctuation\">,</span>\n\t<span class=\"token keyword\">boolean</span> includeFactoryBeans<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>ListableBeanFactory는 팩토리 내의 bean을 나열하는 것을 지원하는 하위 인터페이스다. 이는 정의된 bean의 수, 모든 bean의 이름, 주어진 유형의 인스턴스인 bean의 이름을 검색하는 메서드를 제공한다.</p>\n<p>ListableBeanFactory를 사용하면 프로그램이 실행되는 도중에, 즉 런타임에 어떤 객체들이 필요한지 알게 되고, 그 객체들과 함께 작동하게 만들 수 있다.</p>\n<p>다시 말해, 프로그램을 작성할 때 모든 객체를 미리 알 수 없을 때, ListableBeanFactory를 사용하면 실행 중에 필요한 객체들을 찾아서 그것들과 함께 작업할 수 있게 도와준다.</p>\n<p>어떤 객체들은 초기화와 종료 시점에 콜백을 받길 원할 수 있다. Spring의 빈 팩토리는 이를 위한 두 가지 방법을 제공한다. 콜백 인터페이스를 구현하거나, 콜백 메서드를 선언적으로 지정하는 것이다.</p>\n<p>Spring에서 제공하는 두 개의 콜백 인터페이스는 org.springframework.beans.factory.InitializingBean과 org.springframework.beans.factory.DisposableBean이다. 이들은 속성이 설정된 후와 빈 팩토리가 종료될 때 간단한 인자 없는 콜백 메서드를 제공한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">InitializingBean</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">afterPropertiesSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">DisposableBean</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">destroy</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>때로는 특정 빈이 자신이 속해 있는 빈 팩토리에 직접 접근해야 할 때가 있다. 예를 들어, 빈이 자신을 관리하는 빈 팩토리의 다른 서비스나 기능을 사용하려 할 때 그렇다.</p>\n<p>이런 경우를 위해 Spring은 초기화 시점에 해당 빈에게 자신이 속해 있는 빈 팩토리의 참조(reference)를 제공하는 콜백(callback) 기능을 제공한다. 이렇게 하면 빈은 자신을 관리하는 빈 팩토리에 직접 접근할 수 있다.</p>\n<p>이 콜백을 수신하기 위해서는 BeanFactoryAware 인터페이스를 구현하면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">BeanFactoryAware</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Aware</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">setBeanFactory</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BeanFactory</span> beanFactory<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이러한 setBeanFactory 메서드는 InitializingBean 인터페이스의 afterPropertiesSet 메서드보다 먼저 호출된다.\n소개한 인터페이스는 애플리케이션 코드보다 Spring 프레임워크 자체 내에서 더 자주 사용된다.</p>\n<h2 id=\"Spring-ApplicationContext\" style=\"position:relative;\">Spring ApplicationContext<a href=\"#Spring-ApplicationContext\" aria-label=\"Spring ApplicationContext permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Spring은 빈 팩토리(bean factory)를 확장하여 애플리케이션 컨텍스트(application context) 라는 개념을 제공한다. 애플리케이션 컨텍스트는 빈 팩토리의 기능을 포함하면서도 추가적인 기능들을 제공한다.</p>\n<ul>\n<li>메시지 소스 지원: 키를 통해 지역화된 메시지를 일반적인 방식으로 검색하는 기능을 제공한다. 기본 구현은 리소스 번들에서 메시지를 읽어온다.</li>\n<li>파일 리소스 접근: 실제 리소스 환경(예: 파일 시스템 또는 ServletContext)에 의존하지 않고 상대 경로를 통해 리소스를 로드하는 기능이다.</li>\n<li>애플리케이션 이벤트 지원: Observer 디자인 패턴의 구현으로, 등록된 애플리케이션 리스너에게 애플리케이션 이벤트를 발행한다. 이를 통해 이벤트 발송자와 수신자 간의 결합도를 낮춘다. 또한, 리스너는 컨텍스트 생명주기 이벤트의 알림도 받을 수 있다. Spring의 AOP 프레임워크는 애플리케이션 \"이벤트\"의 알림 설정을 위한 대안이 될 수 있다.</li>\n</ul>\n<p>중심이 되는 인터페이스는 ApplicationContext이다. 이 인터페이스는 ListableBeanFactory를 확장한다. 따라서 애플리케이션 코드는 ApplicationContext를 마치 BeanFactory처럼 사용할 수 있다.</p>\n<h3 id=\"BeanFactoryPostProcessor\" style=\"position:relative;\">BeanFactoryPostProcessor<a href=\"#BeanFactoryPostProcessor\" aria-label=\"BeanFactoryPostProcessor permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>애플리케이션 컨텍스트는 Bean Factory Post-processing 라는 기능을 제공한다. 이 기능을 통해 애플리케이션 컨텍스트에서 읽어들인 빈 정의를 수정하거나 변경할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@FunctionalInterface</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">BeanFactoryPostProcessor</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">postProcessBeanFactory</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ConfigurableListableBeanFactory</span> beanFactory<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이 인터페이스를 구현하면 컨텍스트가 시작될 때 이 후처리기들은 콜백을 받을 수 있으며, 다른 모든 빈들보다 먼저 적용되기 때문에 다른 빈의 정의를 변경할 수 있다.</p>\n<p>예를 들면, 빈의 설정 정보(XML 등)에 정확한 값 대신에 플레이스홀더가 들어갈 수 있다. 데이터베이스 연결 정보나 외부 API 키 같은 민감한 정보를 직접 XML에 쓰는 대신 {db_password}와 같은 플레이스홀더를 사용할 수 있다.</p>\n<p>즉, 후처리는 빈의 설정 정보를 최종적으로 조정하거나 완성하는 단계라고 볼 수 있다.</p>\n<h2 id=\"스프링-DI의-내부-동작\" style=\"position:relative;\">스프링 DI의 내부 동작<a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-DI%EC%9D%98-%EB%82%B4%EB%B6%80-%EB%8F%99%EC%9E%91\" aria-label=\"스프링 DI의 내부 동작 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞서 언급한 인터페이스들은 스프링 컨테이너의 내부 구현에 있어 핵심적인 역할을 하는 인터페이스이다. 그러나 일반 애플리케이션 개발자가 직접 사용할 일은 많지 않다.\n여기서는 스프링의 DI가 이러한 핵심 인터페이스들을 어떻게 활용하여 동작하는지에 대해 살펴볼 것이다.</p>\n<p>컴포넌트 스캔, 세부적인 구현 등 복잡한 내용은 일단 제쳐두고, 앞서 살펴본 핵심 인터페이스로 @Autowired의 DI 동작 방식에 초점을 맞춰보자.\n아래 예제는 Programmatic 방식으로 DI를 적용한 예시이다.</p>\n<ol>\n<li>ItemService 와 ItemRepository 인터페이스를 구현한다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ItemService</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Autowired</span> <span class=\"token class-name\">ItemRepository</span> itemRepository<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printItemName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>itemRepository<span class=\"token punctuation\">.</span><span class=\"token function\">getItemName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ItemRepository</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token class-name\">String</span> <span class=\"token function\">getItemName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ItemRepositoryImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ItemRepository</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getItemName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol start=\"2\">\n<li>Annotation Config 기반 스프링 빈을 설정한다.</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyConfig</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Bean</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ItemRepository</span> <span class=\"token function\">itemRepository</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ItemRepositoryImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol start=\"3\">\n<li>\n<p>AutowireCapableBeanFactory 빈 팩토리를 사용하여 ItemService 의존성을 주입한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DIApplication</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token class-name\">ApplicationContext</span> context <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AnnotationConfigApplicationContext</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MyConfig</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token class-name\">AutowireCapableBeanFactory</span> beanFactory <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">getAutowireCapableBeanFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// Spring의 제어 밖에서 ItemService의 인스턴스를 생성한다</span>\n\t<span class=\"token class-name\">ItemService</span> itemService <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ItemService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// AutowireCapableBeanFactory를 사용하여 의존성을 자동 주입한다.</span>\n\tbeanFactory<span class=\"token punctuation\">.</span><span class=\"token function\">autowireBean</span><span class=\"token punctuation\">(</span>itemService<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token comment\">// itemService 의 의존성 주입이 완료되었다.</span>\n\titemService<span class=\"token punctuation\">.</span><span class=\"token function\">printItemName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// output : \"hello world\"</span>\n\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n</li>\n</ol>\n<p>위의 예제에서, ItemService의 인스턴스는 Spring의 빈 생명주기를 관리하지 않는 외부에서 생성되었지만, AutowireCapableBeanFactory를 사용하여 ItemRepository 인터페이스에 대한\n의존성을 주입할 수 있다.</p>\n<p>AutowireCapableBeanFactory는 BeanFactory의 확장 인터페이스로 기존의 빈 인스턴스에 대한 자동 와이어링 기능을 제공하는 인터페이스이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">AutowireCapableBeanFactory</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">BeanFactory</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token comment\">/**\n\t * Populate the given bean instance through applying after-instantiation callbacks\n\t * and bean property post-processing (e.g. for annotation-driven injection).\n\t * &lt;p>Note: This is essentially intended for (re-)populating annotated fields and\n\t * methods, either for new instances or for deserialized instances. It does\n\t * &lt;i>not&lt;/i> imply traditional by-name or by-type autowiring of properties;\n\t * use {@link #autowireBeanProperties} for those purposes.\n\t * @param existingBean the existing bean instance\n\t * @throws BeansException if wiring failed\n\t */</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">autowireBean</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Object</span> existingBean<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">BeansException</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>autowireBean 메서드는 주어진 빈 인스턴스에 대한 후처리(Post-Processing)를 수행하여 @Autowired와 같은 어노테이션을 사용한 필드나 메서드를 채우는 역할을 한다.\nautowireBean 메서드는 주어진 빈 인스턴스에 대해 @Autowired와 같은 어노테이션을 사용하여 필드나 메서드에 값을 주입하는 역할을 한다.   </p>\n<p>메서드의 내부 구현을 살펴보면 아래와 같은 로직을 확인할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InstantiationAwareBeanPostProcessor</span> bp <span class=\"token operator\">:</span> <span class=\"token function\">getBeanPostProcessorCache</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>instantiationAware<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token class-name\">PropertyValues</span> pvsToUse <span class=\"token operator\">=</span> bp<span class=\"token punctuation\">.</span><span class=\"token function\">postProcessProperties</span><span class=\"token punctuation\">(</span>pvs<span class=\"token punctuation\">,</span> bw<span class=\"token punctuation\">.</span><span class=\"token function\">getWrappedInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> beanName<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token comment\">// ...\t</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>InstantiationAwareBeanPostProcessor 인스턴스들을 순회하며 postProcessProperties 메서드를 호출하는 것을 볼 수 있다. InstantiationAwareBeanPostProcessor 인터페이스는 BeanPostProcessor의 확장으로, 프로퍼티의 사후 처리를 위한 추가적인 콜백 메서드를 제공한다.</p>\n<p>실제로 의존성 주입은 InstantiationAwareBeanPostProcessor 인터페이스를 구현한 AutowiredAnnotationBeanPostProcessor 클래스의 postProcessProperties 메서드 내에서 수행된다.</p>\n<p>아래는 AutowiredAnnotationBeanPostProcessor 클래스의 postProcessProperties() 메서드 코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AutowiredAnnotationBeanPostProcessor</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">SmartInstantiationAwareBeanPostProcessor</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">BeanFactoryAware</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">PropertyValues</span> <span class=\"token function\">postProcessProperties</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">PropertyValues</span> pvs<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> bean<span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span> beanName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">InjectionMetadata</span> metadata <span class=\"token operator\">=</span> <span class=\"token function\">findAutowiringMetadata</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> bean<span class=\"token punctuation\">.</span><span class=\"token function\">getClass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> pvs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n\t\t\tmetadata<span class=\"token punctuation\">.</span><span class=\"token function\">inject</span><span class=\"token punctuation\">(</span>bean<span class=\"token punctuation\">,</span> beanName<span class=\"token punctuation\">,</span> pvs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BeanCreationException</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">throw</span> ex<span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> ex<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">BeanCreationException</span><span class=\"token punctuation\">(</span>beanName<span class=\"token punctuation\">,</span> <span class=\"token string\">\"Injection of autowired dependencies failed\"</span><span class=\"token punctuation\">,</span> ex<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">return</span> pvs<span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>metadata.inject(bean, beanName, pvs); 라인에서 실제로 의존성 주입이 발생한다.</p>\n<p>AutowiredAnnotationBeanPostProcessor가 의존성을 주입하기 위해서는 먼저 주입할 객체가 Spring 컨테이너에서 관리되어야 한다. 그리고 해당 컨테이너를 참조하여 필요한 객체를 찾아야 한다.\n이때 컨테이너를 어떻게 참조할까? 바로 BeanFactoryAware 인터페이스를 구현함으로써 beanFactory를 주입받을 수 있다. AutowiredAnnotationBeanPostProcessor는 내부적으로 주입받은 beanFactory를 멤버 변수에 저장하고 있다. 그리고 postProcessProperties 메서드가 호출될 때, 이 beanFactory를 사용하여 필요한 빈을 검색하고, 그것을 통해 DI를 수행한다.</p>\n<p>위에서 살펴본 Spring의 핵심 인터페이스인 beanFactory -> BeanPostProcessor -> BeanFactoryAware -> beanFactory 중심으로 코드가 나타나고 있는 것을 볼 수 있다.</p>\n<h2 id=\"완전한-Spring-IoC\" style=\"position:relative;\">완전한 Spring IoC<a href=\"#%EC%99%84%EC%A0%84%ED%95%9C-Spring-IoC\" aria-label=\"완전한 Spring IoC permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>위에서 살펴본 예제는 DI의 작동 방식을 설명하기 위한 것으로 완전한 IoC가 적용된 것으로 보기는 어렵다.\n코드 내에서 직접 컨텍스트를 생성하고, 인스턴스를 만들며, 주입하는 과정이 특정 기술에 의존적인 침투적인 방식으로 작성되었다.\n이제 Spring에 제어권을 넘기고, 컨텍스트의 생성과 객체의 생성 및 조립을 프레임워크에 완전히 위임하는 방식을 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ItemService</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token class-name\">ItemRepository</span> itemRepository<span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">printItemName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>itemRepository<span class=\"token punctuation\">.</span><span class=\"token function\">getItemName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">ItemRepository</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token class-name\">String</span> <span class=\"token function\">getItemName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ItemRepositoryImpl</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">ItemRepository</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Override</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">getItemName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token string\">\"hello world\"</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Configuration</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyConfig</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Bean</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ItemService</span> <span class=\"token function\">itemService</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ItemService</span><span class=\"token punctuation\">(</span><span class=\"token function\">itemRepository</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\t\n\t\n\t<span class=\"token annotation punctuation\">@Bean</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ItemRepository</span> <span class=\"token function\">itemRepository</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ItemRepositoryImpl</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@SpringBootApplication</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DIApplication</span> <span class=\"token punctuation\">{</span>\n\n\t<span class=\"token annotation punctuation\">@Autowired</span> <span class=\"token class-name\">ItemService</span> itemService<span class=\"token punctuation\">;</span>\n\t\n\t<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token class-name\">SpringApplication</span><span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">DIApplication</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token annotation punctuation\">@Bean</span>\n\t<span class=\"token keyword\">public</span> <span class=\"token class-name\">ApplicationRunner</span> <span class=\"token function\">applicationRunner</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">return</span> args <span class=\"token operator\">-></span> itemService<span class=\"token punctuation\">.</span><span class=\"token function\">printItemName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>SpringApplication.run 메서드가 실행되면서 메인 스레드의 제어권이 스프링 프레임워크로 넘어간다.\n그 후, Spring 프레임워크는 @Configuration 이 붙은 자바 설정 파일을 읽어 설정 파일에 맞게 객체를 생성하고 조립한다.\n우리는 객체 조립에 대한 설정 파일만 제공한하면 Spring이 나머지 작업을 처리해준다.</p>\n<h2 id=\"마무리\" style=\"position:relative;\">마무리<a href=\"#%EB%A7%88%EB%AC%B4%EB%A6%AC\" aria-label=\"마무리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>경량 컨테이너의 특징과 그 장점을 살펴보았고 IoC 컨테이너의 필요성에 대해서도 살펴보았다.\nDependency Injection은 IoC의 중심 역할을 한다는 것을 알게 되었다.\n더불어, 스프링에서 IoC 컨테이너를 어떻게 구성하는지, 그리고 그것이 실제로 어떻게 작동하는지 핵심 인터페이스와 함께 구체적인 예제를 통해 알아보았다.</p>\n<p>스프링은 트랜잭션 추상화, 캐시 추상화, AOP 등의 엔터프라이즈 개발 API를 손쉽게 제공하지만, 그 중심에는 IoC 컨테이너가 있다고 생각한다.\nIoC 컨테이너는 객체지향 조립 프레임워크의 역할을 하며, 이를 통해 객체 지향 설계에 집중할 수 있게 되었다.\n그렇지 않았다면, 객체를 조립하고 생성하는 데에 훨씬 더 많은 시간을 소비했을 것이다.</p>\n<h2 id=\"참조\" style=\"position:relative;\">참조<a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>Expert One-on-One J2EE Development without EJB (Rod Johnson, Juergen Hoeller) </li>\n<li><a href=\"https://docs.spring.io/spring-framework/reference/core/beans.html\">https://docs.spring.io/spring-framework/reference/core/beans.html</a></li>\n</ul>","frontmatter":{"title":"스프링으로 알아보는 IoC 컨테이너의 원리와 이해","date":"October 11, 2023","update":"October 11, 2023","tags":["스프링"],"series":null},"fields":{"slug":"/spring-core-container/","readingTime":{"minutes":23.49}}},"seriesList":{"edges":[{"node":{"id":"296328f9-f83a-5280-ba4d-bd4de2c4a23a","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"c9052258-da8a-5838-97d0-5affaae34156","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"eaf68b24-edef-59b5-a7f4-4e9ea41b0321","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"522e45a7-12b4-55ae-8295-4a720f58da60","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"5413888c-b834-5d0a-a576-10b33121e612","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"b7dfee63-516c-5cf7-83bd-cfe07286f825","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"a652b497-d0e9-5d72-988a-35fb96da4202","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"142b9f9f-7ca6-5376-aa9b-55bd67d46ee3","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"440239bd-9cf3-519f-86af-72f698bb3262","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"2f0b9a48-2617-5e0a-ab00-4571b7e012c7","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"60bb268c-033b-5cdd-bba3-9351aa771fb4","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"eee5ea21-1271-510f-9b52-f5c2b8e6f8ed","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"e512cc83-75e1-552a-813b-543508957e1f","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"4db40817-9881-5aea-a6d4-b7b009c1a350","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"bb9c36ac-6d3d-53ff-891c-3d0e6d56115a","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"15e07ee1-b1da-592c-97db-c67d8a458b0c","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"00a98f1e-f4b7-562e-b052-7c7bbf333a61","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"d2b050d0-1ad6-5db3-8087-46c1ef770d5d","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"39f89aa8-d521-51b6-af7e-4f25f0648182","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"8934dee6-96ba-552c-bcd6-49294d6e7cc2","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"19fdfd91-656a-5e79-9d96-1f5a12da47ca","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"acc5f56e-6968-539d-9ffc-483a26a0d5ee","fields":{"slug":"/enabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"3dcec820-a2a1-54a0-aaf6-fda09480d78d","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"4329bf0c-4a54-5d63-9354-7dd221de8490","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"b68512de-7b86-5edf-8547-d9e1103dbcf0","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"bdf354b5-bb11-5ca5-b46f-4fe625963602","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"ca70e5d9-9f49-5e98-be76-85def8989dbf","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"f4b0fec2-64a8-50c4-b32f-a4e3165b2c34","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"258fb9df-ac30-55cf-91f5-1d626b51fbc6","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"bc1f40bb-26d9-5ce5-8e40-26be0b6f4ec9","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"9edb5e98-0831-5f05-99ac-5243f5e61ed1","fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}}},{"node":{"id":"be7a2fa8-5b1e-57c0-ac68-164a29e2c50a","fields":{"slug":"/socket_option/"},"frontmatter":{"title":"Java의 Socket Option 정리"}}},{"node":{"id":"380cd3ba-df02-5eb5-bd99-dd88eee889c3","fields":{"slug":"/tomcat-connection/"},"frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?"}}},{"node":{"id":"d3f01e89-0b7e-5518-b223-4f91816fe1fb","fields":{"slug":"/spring-core-container/"},"frontmatter":{"title":"스프링으로 알아보는 IoC 컨테이너의 원리와 이해"}}},{"node":{"id":"74a04ce6-75c4-5373-8a4a-e11360c4778b","fields":{"slug":"/socket_internal/"},"frontmatter":{"title":"요청이 급증하는 상황의 Connection reset by peer 트러블 슈팅"}}},{"node":{"id":"e9743b3d-5c40-582b-ba0f-d58108c30c9a","fields":{"slug":"/mysql-transaction-lock/"},"frontmatter":{"title":"MySQL 잠금과 트랜잭션 Deep Dive"}}},{"node":{"id":"6f0905d8-70e8-531e-b3fa-a1df160991b9","fields":{"slug":"/java-synchronized/"},"frontmatter":{"title":"자바의 synchronized와 volatile"}}}]},"previous":{"fields":{"slug":"/tomcat-connection/"},"frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?"}},"next":{"fields":{"slug":"/java-nio-channel/"},"frontmatter":{"title":"Java NIO - Channel"}}},"pageContext":{"id":"d3f01e89-0b7e-5518-b223-4f91816fe1fb","series":null,"previousPostId":"380cd3ba-df02-5eb5-bd99-dd88eee889c3","nextPostId":"8cdeb773-b5ee-5273-9916-fcaa73367475"}},"staticQueryHashes":[],"slicesMap":{}}