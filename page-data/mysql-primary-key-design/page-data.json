{"componentChunkName":"component---src-templates-post-jsx","path":"/mysql-primary-key-design/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"markdownRemark":{"id":"bc1f40bb-26d9-5ce5-8e40-26be0b6f4ec9","excerpt":"Primary Key 설계의 중요성 InnoDB 기준으로 MySQL은 Primary Key를 기준으로 데이터를 클러스터링한다. \n클러스터링이라는 용어는 인접한 키 값이 있는 레코드가 물리적으로도 인접하게 저장된다는 것을 말한다.\n즉, 논리적인 PK 값에 의해 레코드의 물리적인 위치가 결정된다.\nPK값이 변경된다면 해당 레코드의 물리적인 위치도 변경된다는 …","html":"<h2 id=\"Primary-Key-설계의-중요성\" style=\"position:relative;\">Primary Key 설계의 중요성<a href=\"#Primary-Key-%EC%84%A4%EA%B3%84%EC%9D%98-%EC%A4%91%EC%9A%94%EC%84%B1\" aria-label=\"Primary Key 설계의 중요성 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>InnoDB 기준으로 MySQL은 Primary Key를 기준으로 데이터를 클러스터링한다.\n클러스터링이라는 용어는 인접한 키 값이 있는 레코드가 물리적으로도 인접하게 저장된다는 것을 말한다.\n즉, 논리적인 PK 값에 의해 레코드의 물리적인 위치가 결정된다.\nPK값이 변경된다면 해당 레코드의 물리적인 위치도 변경된다는 얘기다.   </p>\n<p>모든 데이터베이스가 마찬가지겠지만 MySQL의 PK 설계는 다른 데이터베이스보다 더 중요하다고 볼 수 있다.\n왜냐하면, 일부 데이터베이스에서는 클러스터링할 인덱스를 선택할 수 있지만 MySQL은 기본키로 고정되어 변경할 수 없다. (MySQL 8.x 기준)<br>\n또한, MySQL은 Secondary Index의 Leaf Node에 오라클과 같이 물리적 위치에 대한 참조(ROWID)가 아닌 PK 값을 저장하고, PK 인덱스를 통해 실제 디스크 블록에 접근한다. 따라서, MySQL에서 PK 는 단순히 데이터를 식별하기 위한 식별자 역할뿐만 아니라 내부 구현에도 관여하기 때문에 그 중요성은 매우 크다고 볼 수 있다.</p>\n<h2 id=\"클러스터형-인덱스\" style=\"position:relative;\">클러스터형 인덱스<a href=\"#%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%ED%98%95-%EC%9D%B8%EB%8D%B1%EC%8A%A4\" aria-label=\"클러스터형 인덱스 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>고성능을 위한 Primary Key 를 설계하기 위해서는 Primary Key 의 저장 구조인 클러스터형 인덱스에 대한 이해가 필요하다.\n아래의 그림은 <strong>Secondary Index</strong>(Non-Clusted Index) 와 <strong>Primary Key Index</strong>(Clusted Index) 의 저장 구조를 나타낸다.   </p>\n<p><strong>Secondary Index</strong>(Non-Clusted Index) 그림의 리프 노드를 보면 Index Key 값에 해당 하는 Primary Key 값을 저장하고 있는 것을 볼 수 있다.\nIndex Key 값은 정렬되어 있지만 Index Key 값에 맵핑되는 Primary Key들 사이에는 아무런 순서관계가 없다.</p>\n<p><strong>Primary Key Index</strong>(Clusted Index) 그림의 리프 노드는 Index Key 값 기준으로 정렬되어 있고,\n참조가 아닌 실제 레코드를 저장하는 페이지가 리프노드에 위치해 있다. 페이지 내에서도 Primary Index Key 값 기준으로 레코드가 물리적으로 정렬되어 있다.</p>\n<!-- more -->\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/a67dad59e6a37da0b5730238ef926ae2/f97d7/index-tree.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 72.94117647058825%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACDElEQVR42p2Ta2+iQBiF/f//Zj/sl00v2nQ3rbV1d1vXFRURQQXkLggjcPYwpU3TaGt2kjckM8zzXs6ZFt4tz7axms0QBcHrXlVVMk5ZLXmhLJ9hvo/QsZHYFubTKVzXfQWeuiRw67mwxmO4jgOx38uDXZbBNU1EqyV87qe73WnA9WoFQ5tB+zuEuVgg2W7lgW1ZMNj6gommioJdmp4GnPR62MxURJoKY/AI8/E3/MkYPvfssYLINGApI6TLJTwmyYX4GFgUBQq2I1hBXe1gMEDAWYokQckzKQhnXDAyjkEQWDYzPy4KYVb3BlrnEqsf19AuzhCNhrUaEvYCDSiWvdAR+t5RB0gg0gThdRvOxTeUD12E7TOI4RMqClTlOcBKXVYfW2vkgQ+Vcw3D8KADJLDM2QovZmynjpwAwSQyF6vRKZizXqNsLqfsyNZ1BJyvW9vsjWCtJo2somLIb20d7hm8ZKgqdKpszOdI4lj+brFaU9MwH40wYWyj6B3w7Wqq2NGbk34fG3WKZGli3n+ActeFN1EQEL6h1WIq79BaKat3+cKE2B8AvnCLPUq2X1DZPI5gGAb+DJ4QMJHYxijZRbkXsquqVr5xROszo5a0lH9/C+fuBvpVG3r7HM6vn0ef5AfA558rAsOrS8TfO9h0zmF+/QKvd/s/wKZCtpbyOWY5HZDl8o3nzfM8ZOx/bpOGDyoIltcAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='img.png' title='' src='/static/a67dad59e6a37da0b5730238ef926ae2/ca1dc/index-tree.png' srcset='/static/a67dad59e6a37da0b5730238ef926ae2/e7570/index-tree.png 170w,\n/static/a67dad59e6a37da0b5730238ef926ae2/f46e7/index-tree.png 340w,\n/static/a67dad59e6a37da0b5730238ef926ae2/ca1dc/index-tree.png 680w,\n/static/a67dad59e6a37da0b5730238ef926ae2/02d09/index-tree.png 1020w,\n/static/a67dad59e6a37da0b5730238ef926ae2/9d567/index-tree.png 1360w,\n/static/a67dad59e6a37da0b5730238ef926ae2/f97d7/index-tree.png 2000w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>img.png</figcaption>\n  </figure></p>\n<p>Clusted Index는 구조적인 이유로 순차적인 Key 값을 넣을 때, 오버헤드가 가정 적고 가장 빠르다. 단순히 Index 트리 오른쪽 맨끝에 새로운 레코드를 삽입해주기만 하면 된다.<br>\n반면에 비순차적인 Key 값이 들어오게 되면 상황이 복잡해진다. Key 값이 기존 데이터 중간에 삽입될 수 있으므로 트리 구조를 변경사항에 맞게 갱신해야 한다.<br>\n또한, 리프 노드의 페이지 안에 있는 데이터의 순서도 조정이 필요하다. 기존 데이터 사이에 새 레코드의 적절한 위치를 찾고 공간을 확보해야 한다. 이로 인해 많은 데이터의 이동이 필요할 수 있고 페이지 분할로 단편화 문제가 발생할 수 있다.</p>\n<p>따라서 INSERT 속도가 중요한 테이블이라면 순차적인 값을 Primary Key로 선정하는 것이 유리하다.</p>\n<h2 id=\"Primary-Key-유형\" style=\"position:relative;\">Primary Key 유형<a href=\"#Primary-Key-%EC%9C%A0%ED%98%95\" aria-label=\"Primary Key 유형 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"자동-증가-Auto-Increment-Primary-Key\" style=\"position:relative;\">자동 증가 (Auto Increment) Primary Key<a href=\"#%EC%9E%90%EB%8F%99-%EC%A6%9D%EA%B0%80-Auto-Increment-Primary-Key\" aria-label=\"자동 증가 Auto Increment Primary Key permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><strong>장점</strong></p>\n<ul>\n<li>Primary Key 채번을 DB에 위임하므로 관리 포인트가 줄어든다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>테이블의 대량 INSERT 작업 시, Auto Increament 에서 병목현상이 발생할 수 있다.</li>\n</ul>\n<h3 id=\"UID\" style=\"position:relative;\">UID<a href=\"#UID\" aria-label=\"UID permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>클러스터형 인덱스 구조를 이해하면, UUID와 같은 랜덤 값이 Primary Key로 선정될 경우, 레코드 클러스터링에 필요한 오버헤드만 발생하고 크게 이점이 없음을 알 수 있다.\n그러나 랜덤 UID가 아닌 순차적인 UID를 생성하면 Auto Increment의 병목현상과 클러스터링 오버헤드를 모두 피할 수 있다.\n순차적인 UID는 (현재시각 + 일련번호) 또는 (epoch time + 일련번호)와 같은 조합으로 순서를 유지하는 UID를 만들 수 있다.</p>\n<p><strong>장점 (Sequential UID)</strong></p>\n<ul>\n<li>대량 INSERT 작업을 매우 빠르게 처리할 수 있다.</li>\n</ul>\n<p><strong>단점 (Sequential UID)</strong></p>\n<ul>\n<li>클라이언트에서 순차적인 UID를 만들기 위해 관리가 필요하다.</li>\n</ul>\n<h3 id=\"Composite-key\" style=\"position:relative;\">Composite key<a href=\"#Composite-key\" aria-label=\"Composite key permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>논리 모델링과 물리 모델링의 격차가 적고, 사람이 이해하기 쉽다. 중복키 값이 들어올 수 있으므로 동시성 관리가 필요하다.</p>\n<p><strong>장점</strong></p>\n<ul>\n<li>공간적 지역성(Spatial Locality) 를 활용할 수 있다.</li>\n</ul>\n<p><strong>단점</strong></p>\n<ul>\n<li>클라이언트에서 채번에 대한 동시성 관리가 필요하다.</li>\n</ul>\n<h2 id=\"대리키와-복합키-비교\" style=\"position:relative;\">대리키와 복합키 비교<a href=\"#%EB%8C%80%EB%A6%AC%ED%82%A4%EC%99%80-%EB%B3%B5%ED%95%A9%ED%82%A4-%EB%B9%84%EA%B5%90\" aria-label=\"대리키와 복합키 비교 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Auto increament 와 UID 를 이용한 기본키 유형은 대리키로 일반화할 수 있다. Primary Key를 대리키로 구성한 방식과 복합키로 구성한 방식의 차이점을 비교해본다.</p>\n<h3 id=\"부모테이블의-기본키를-자식-테이블의-기본키로-쓰지-않고-외래키로-사용하는-경우-비식별관계\" style=\"position:relative;\">부모테이블의 기본키를 자식 테이블의 기본키로 쓰지 않고, 외래키로 사용하는 경우 (비식별관계)<a href=\"#%EB%B6%80%EB%AA%A8%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EA%B8%B0%EB%B3%B8%ED%82%A4%EB%A5%BC-%EC%9E%90%EC%8B%9D-%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EA%B8%B0%EB%B3%B8%ED%82%A4%EB%A1%9C-%EC%93%B0%EC%A7%80-%EC%95%8A%EA%B3%A0-%EC%99%B8%EB%9E%98%ED%82%A4%EB%A1%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0-%EB%B9%84%EC%8B%9D%EB%B3%84%EA%B4%80%EA%B3%84\" aria-label=\"부모테이블의 기본키를 자식 테이블의 기본키로 쓰지 않고 외래키로 사용하는 경우 비식별관계 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/1f5e3d12fa6da564430f23e5ca41b243/b72ad/mysql_img_1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 27.647058823529413%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAy0lEQVR42pVQywqEMAzs//+aR0HB10FBREVsfT9ndwJZxNsGhrbJZKaJwR9xnheO4/iep+C+b8lf1/WDIeGZIOn51hzDWoe+77HvO5ZlQRzHCMMQzjnM84xhGGC6rpMiUVUVsiyT+ziOmKZJyBRlkBtFEXzfh+d5SNNUDJQrgkEQIM9zEWGztVaKBF2bppEG1ouiQJIkIlTXNdZ1lRVs2yYgx7RtK4Ja5DgKvunKfTEoTNOyLOX+Dtmh/kbHfoO/1B3SlAY6ImtPMPcB2IbQKDoxQukAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mysql_img_1.png' title='' src='/static/1f5e3d12fa6da564430f23e5ca41b243/ca1dc/mysql_img_1.png' srcset='/static/1f5e3d12fa6da564430f23e5ca41b243/e7570/mysql_img_1.png 170w,\n/static/1f5e3d12fa6da564430f23e5ca41b243/f46e7/mysql_img_1.png 340w,\n/static/1f5e3d12fa6da564430f23e5ca41b243/ca1dc/mysql_img_1.png 680w,\n/static/1f5e3d12fa6da564430f23e5ca41b243/02d09/mysql_img_1.png 1020w,\n/static/1f5e3d12fa6da564430f23e5ca41b243/b72ad/mysql_img_1.png 1242w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>mysql_img_1.png</figcaption>\n  </figure></p>\n<p>Post, Comment 테이블 둘 다 Auto Increament 기본키를 사용하고, Comment 테이블에 post_id FK 를 두어 Post와 연관관계를 맺는 방식이다.\nPost 테이블이 Driving Table이고 Comment 테이블이 Driven Table 인 경우 두 테이블을 조인하게 되면 아래 그림와 같은 방식으로 데이터를 탐색하게 된다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/78873/mysql_img_2.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 58.235294117647065%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABJ0lEQVR42o2Sy4qGMAxG//d/NhfiQpcq4kJExfvdDCeQ4vyMOIUQ26QnX2I/8rC2bZNxHKXrOvXYuq4ufl2XnmVZJnEcS13XeufzBKyqSnzflzAMJQgC8TxP8jx38eM4pCgKSZJEjVjf938DqU6QqsMwSFmWauyJGRBDddu2+v2o8DxPmaZJk+d5VuiyLHp2B+77rnHGAuwVCIg5oRbP/htoCvl+BVIdDxCF30DOgP1q2aqwuQO5TCKwpml0hrRmQCvGfdQ7hfyhKIokTVOXfG8ZD4i/zp4YF1GHKuL8LKeQA4wqHLKoZvOzlgECBkRhmyEQch3Qhm2Pl1bwtGtAQLQMGAgqLc9G41qmIkGMWRKw54DZczF1XDJ1eHJe3+F/lqlEBIXMfgDl9Kcs3J4rhwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mysql_img_2.png' title='' src='/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/ca1dc/mysql_img_2.png' srcset='/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/e7570/mysql_img_2.png 170w,\n/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/f46e7/mysql_img_2.png 340w,\n/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/ca1dc/mysql_img_2.png 680w,\n/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/02d09/mysql_img_2.png 1020w,\n/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/9d567/mysql_img_2.png 1360w,\n/static/e16c9fb809bb5cbd5d5e61d54e7e48f4/78873/mysql_img_2.png 1520w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>mysql_img_2.png</figcaption>\n  </figure></p>\n<p>조인 연산을 수행하기 위해, Post 테이블의 기본키와 연결된 Comment 테이블의 Post_id 값으로 조인이 이루어진다. Comment 테이블의 post_id에는 이미 인덱스가 생성되어 있기 때문에, Index Range Scan을 사용하여 Post 테이블과 Comment 테이블을 맵핑할 수 있다.</p>\n<p>그 다음 단계에서는 SELECT 결과를 가져오기 위해 Comment 테이블의 레코드를 검색한다. 이 과정에서 Comment 레코드의 탐색을 위해 Random I/O가 발생하게 된다. Comment 테이블의 POST_ID_IDX 인덱스는 POST_ID별로 정렬되어 있어 같은 POST_ID를 가지더라도 COMMENT_ID는 멀리 떨어져있는 값을 가질 수 있다.</p>\n<p>예를 들어 위의 그림에서, Post 테이블에서 id=3인 레코드를 조회하면, Comment 테이블의 post_id와의 조인 결과로 Comment id (100, 200)이 반환된다. 페이지 당 50개 레코드가 저장된다고 가정하면 2개의 Comment 레코드를 가져오기 위해 총 2개의 페이지 읽기 작업이 필요하게 된다.</p>\n<h3 id=\"부모테이블의-기본키를-자식-테이블-기본키에-포함하는-경우-식별관계\" style=\"position:relative;\">부모테이블의 기본키를 자식 테이블 기본키에 포함하는 경우 (식별관계)<a href=\"#%EB%B6%80%EB%AA%A8%ED%85%8C%EC%9D%B4%EB%B8%94%EC%9D%98-%EA%B8%B0%EB%B3%B8%ED%82%A4%EB%A5%BC-%EC%9E%90%EC%8B%9D-%ED%85%8C%EC%9D%B4%EB%B8%94-%EA%B8%B0%EB%B3%B8%ED%82%A4%EC%97%90-%ED%8F%AC%ED%95%A8%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0-%EC%8B%9D%EB%B3%84%EA%B4%80%EA%B3%84\" aria-label=\"부모테이블의 기본키를 자식 테이블 기본키에 포함하는 경우 식별관계 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/dc6ee2a60d393df21fcb393cd6e4ecdc/abff7/mysql_img_3.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 29.411764705882355%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAx0lEQVR42pVR2QqEQAyb//8+QXxwwAtXZEbxdjyypFBZfNtCcChJmlaDP2rbNuz7jhACxnFE13VY11V6xHmeMErid1kWDMMgbwXFrOM44JwXDvlFUSCOY/R9L71pmgSmrj8yiWLvPbIse8yVqIZt2yJNU1hrcV2X9O/7fsC0hgZJkmCe5ye+mhHOORnAJE3TIM9zRFGEqqrEhMZqSL6hEUU04w24ItMomJBkmnITGpVlKQHekJX1oHrHN2iqxWEUUcz3r1Z/yhfJf9Dl20Hy0wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mysql_img_3.png' title='' src='/static/dc6ee2a60d393df21fcb393cd6e4ecdc/ca1dc/mysql_img_3.png' srcset='/static/dc6ee2a60d393df21fcb393cd6e4ecdc/e7570/mysql_img_3.png 170w,\n/static/dc6ee2a60d393df21fcb393cd6e4ecdc/f46e7/mysql_img_3.png 340w,\n/static/dc6ee2a60d393df21fcb393cd6e4ecdc/ca1dc/mysql_img_3.png 680w,\n/static/dc6ee2a60d393df21fcb393cd6e4ecdc/02d09/mysql_img_3.png 1020w,\n/static/dc6ee2a60d393df21fcb393cd6e4ecdc/abff7/mysql_img_3.png 1267w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>mysql_img_3.png</figcaption>\n  </figure></p>\n<p>두번째 예에서는 Comment가 POST의 ID를 자신의 기본키에 포함시킨 Composite Key로 PK를 구성한 예이다. 마찬가지로 아래는 Post 테이블이 Driving Table이고 Comment 테이블이 Driven Table 인 경우 두 테이블을 조인할 때, 데이터 탐색 방식이다.</p>\n<p><figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; '>\n      <a class='gatsby-resp-image-link' href='/static/fdb57c196b73d47622224329f6014673/f0e87/mysql_img_4.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 57.64705882352942%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABJUlEQVR42nWS2QqEMAxF5///T3xQQV8UEfd9zXA6xOk4WgitTXq8N+1LHsZxHLKuq0zTJPM8y7ZtZs8e5LMskziOpWkak389waqqkiAIxHVdcRxHPM+Tuq5P6L7vBsQ+NWEYSlmW90AGySRJDJg5iiLJ8/wHiEKUD8NwurkFUtx1nYzjaKxwQIOcDaSGn7OmNY+W27Y1gU1mlPZ9/wcEAnBZlg/w2mgFchgLwFDB+grEripk/QO0wQrEIkDWKLyzDIj8adn3fSHSNP3rIQGQmQu5AgGQK4riq5Ae0XgSWqwKCVUIkJmDqFGQ5k+FwAgS+ohZ0xf2scq31untU8tFAELUqVCfg6phkwMc1H2+tQ4AQ5Xaz8a8Q+xpXG/6Luw+A7B/SrwBZvWna8XSdDQAAAAASUVORK5CYII='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='mysql_img_4.png' title='' src='/static/fdb57c196b73d47622224329f6014673/ca1dc/mysql_img_4.png' srcset='/static/fdb57c196b73d47622224329f6014673/e7570/mysql_img_4.png 170w,\n/static/fdb57c196b73d47622224329f6014673/f46e7/mysql_img_4.png 340w,\n/static/fdb57c196b73d47622224329f6014673/ca1dc/mysql_img_4.png 680w,\n/static/fdb57c196b73d47622224329f6014673/02d09/mysql_img_4.png 1020w,\n/static/fdb57c196b73d47622224329f6014673/9d567/mysql_img_4.png 1360w,\n/static/fdb57c196b73d47622224329f6014673/f0e87/mysql_img_4.png 1554w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>mysql_img_4.png</figcaption>\n  </figure></p>\n<p>첫번째 방식과 유사하게, 조인이 발생했을 때 Comment 레코드를 읽어오기 위해 페이지 3을 두 번 참조하게 되지만, 이 경우 페이지 3은 이미 캐싱되어 있으므로 두 번째 참조는 추가적인 I/O를 발생시키지 않는다.</p>\n<p>두 방식에서 논리적 페이지 I/O는 2로 동일하지만, 물리적 페이지 I/O(캐시 적용 시)는 각각 2와 1로 다르다. 조인되는 데이터가 많아질수록 두 방식 사이의 물리적 I/O 차이는 더욱 커지게 된다.</p>\n<p>이러한 결과는 두 번째 케이스에서 식별관계를 사용해 기본키를 복합키로 구성했기 때문에 발생한다. POST_ID를 기준으로 조인을 수행할 때, 공간적 지역성(Spatial Locality)의 원리가 적용되었다고 볼 수 있다. 특정 Post에 속한 Comment 집합은 같은 논리적 영역에 속하는 인스턴스라고 볼 수 있다. POST<em>ID와 COMMENT</em>ID로 클러스터링하면, 물리적으로도 POST_ID에 속한 COMMENT 집합이 유사한 영역에 위치하게 되므로 캐싱 확률이 높아지게 된다.</p>\n<p>실제로 같은 페이지 번호에 저장되어 있는 레코드를 탐색하기 위해서 몇번의 I/O가 발생했는지 확인하기 위해서는 MySQL에서 제공하는 상태 변수 중 Innodb_buffer_pool_reads 값을 확인하여 물리적 I/O 발생량을 확인할 수 있다. 해당 상태변수는 버퍼풀에서 읽지못하고 디스크에서 직접 읽은 수를 의미하는 변수이다.</p>\n<h4>데이터를 읽기 전에 Innodb_buffer_pool_reads 값</h4>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">mysql<span class=\"token operator\">></span> SHOW <span class=\"token environment constant\">SESSION</span> STATUS LIKE <span class=\"token string\">'Innodb_buffer_pool_reads%'</span><span class=\"token punctuation\">;</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Variable_name            <span class=\"token operator\">|</span> Value <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Innodb_buffer_pool_reads <span class=\"token operator\">|</span> <span class=\"token number\">1652</span>  <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token number\">1</span> row <span class=\"token keyword\">in</span> <span class=\"token builtin class-name\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.03</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<h4>멀리 떨어진 두 개의 Record를 두 건 읽는 경우 (레코드의 페이지가 다른 경우)</h4>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">select</span> *\n-<span class=\"token operator\">></span> from ORDER\n-<span class=\"token operator\">></span> where ORDER.ORDER_NO <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">2000,3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nSHOW <span class=\"token environment constant\">SESSION</span> STATUS LIKE <span class=\"token string\">'Innodb_buffer_pool_reads%'</span><span class=\"token punctuation\">;</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Variable_name            <span class=\"token operator\">|</span> Value <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Innodb_buffer_pool_reads <span class=\"token operator\">|</span> <span class=\"token number\">1654</span>  <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token number\">1</span> row <span class=\"token keyword\">in</span> <span class=\"token builtin class-name\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.04</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<p>PK가 2000, 3000 인 레코드 두 건을 읽었을 떄 Innodb_buffer_pool_reads 변수가 1652 → 1654 로 증가된 것을 확인할 수 있다. 2번의 Disk I/O가 발생하였다.</p>\n<h4>클러스터링으로 인접한 Record를 두 건 읽는 경우 (레코드 페이지가 같은 경우)</h4>\n<div class=\"gatsby-highlight\" data-language=\"shell\"><pre class=\"language-shell\"><code class=\"language-shell\">mysql<span class=\"token operator\">></span> <span class=\"token keyword\">select</span> *\n-<span class=\"token operator\">></span> from <span class=\"token variable\"><span class=\"token variable\">`</span>MARKETBOM2_SCHM<span class=\"token variable\">`</span></span>.BIZ_SLIP_TRADE\n-<span class=\"token operator\">></span> where BIZ_SLIP_TRADE.TRADE_SLIP_NO <span class=\"token keyword\">in</span> <span class=\"token punctuation\">(</span><span class=\"token number\">5000,5001</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nmysql<span class=\"token operator\">></span> SHOW <span class=\"token environment constant\">SESSION</span> STATUS LIKE <span class=\"token string\">'Innodb_buffer_pool_reads%'</span><span class=\"token punctuation\">;</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Variable_name            <span class=\"token operator\">|</span> Value <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token operator\">|</span> Innodb_buffer_pool_reads <span class=\"token operator\">|</span> <span class=\"token number\">1655</span>  <span class=\"token operator\">|</span>\n+--------------------------+-------+\n<span class=\"token number\">1</span> row <span class=\"token keyword\">in</span> <span class=\"token builtin class-name\">set</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0.01</span> sec<span class=\"token punctuation\">)</span></code></pre></div>\n<p>PK가 5000, 5001 인 레코드를 두 건 읽었을 때 Innodb_buffer_pool_read 변수가 1654 → 1655 로 증가된 것을 확인할 수 있다. 아까와 같이 레코드를 두 건 읽었지만 실제 Disk I/O 발생량은 1번인 것을 확인할 수 있다.</p>\n<h2 id=\"정리\" style=\"position:relative;\">정리<a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>MySQL의 고성능 Primary Key 설계를 위해서는 클러스터링 인덱스의 특성을 이해하고 테이블의 주 용도 및 액세스 패턴을 정확히 파악해야 한다.</p>\n<p>쓰기 중심의 작업에서는 순차적 ID를 사용하여 성능을 최적화할 수 있다. 이는 쓰기 작업 시 디스크 I/O를 효율적으로 하기 위함이다.</p>\n<p>읽기 중심의 작업에서는 Random I/O가 주로 발생한다면 대리키를, Join 많이 걸리거나 업무적으로 연관된 데이터 중심으로 조회가 많이 되는 경우라면 물리적으로 인접할 수 있도록 업무적인 복합키를 구성하는게 유리할 것 이다.</p>\n<p>실제 업무 시스템에서는 중요한 테이블(예: 이커머스의 주문 테이블)에 대해서는 쓰기와 읽기 작업 모두 빈번하게 발생한다. 이런 상황에서는 쓰기와 읽기 간의 트레이드 오프를 고려하여 결정해야한다. 대다수의 시스템에서 쓰기 대비 읽기의 비율이 8:2 또는 9:1로 나타나기 때문에, 읽기 작업에 최적화된 설계를 택하는 것이 대체로 유리할 것 이다.</p>\n<p>중요한것은 MySQL의 클러스터 인덱스와 세컨더리 인덱스 구조를 이해하고, 그 이해를 바탕으로 시스템 요구 사항에 가장 적합한  Primary Key를 선택할 수 있어야 한다.</p>","frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략","date":"August 06, 2023","update":"August 06, 2023","tags":["데이터베이스"],"series":null},"fields":{"slug":"/mysql-primary-key-design/","readingTime":{"minutes":14.44}}},"seriesList":{"edges":[{"node":{"id":"296328f9-f83a-5280-ba4d-bd4de2c4a23a","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"c9052258-da8a-5838-97d0-5affaae34156","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"eaf68b24-edef-59b5-a7f4-4e9ea41b0321","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"522e45a7-12b4-55ae-8295-4a720f58da60","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"5413888c-b834-5d0a-a576-10b33121e612","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"b7dfee63-516c-5cf7-83bd-cfe07286f825","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"a652b497-d0e9-5d72-988a-35fb96da4202","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"142b9f9f-7ca6-5376-aa9b-55bd67d46ee3","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"440239bd-9cf3-519f-86af-72f698bb3262","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"2f0b9a48-2617-5e0a-ab00-4571b7e012c7","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"60bb268c-033b-5cdd-bba3-9351aa771fb4","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"eee5ea21-1271-510f-9b52-f5c2b8e6f8ed","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"e512cc83-75e1-552a-813b-543508957e1f","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"4db40817-9881-5aea-a6d4-b7b009c1a350","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"bb9c36ac-6d3d-53ff-891c-3d0e6d56115a","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"15e07ee1-b1da-592c-97db-c67d8a458b0c","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"00a98f1e-f4b7-562e-b052-7c7bbf333a61","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"d2b050d0-1ad6-5db3-8087-46c1ef770d5d","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"39f89aa8-d521-51b6-af7e-4f25f0648182","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"8934dee6-96ba-552c-bcd6-49294d6e7cc2","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"19fdfd91-656a-5e79-9d96-1f5a12da47ca","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"1e926a5f-341c-585c-a9ef-b00a1e1e4842","fields":{"slug":"/\benabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"3dcec820-a2a1-54a0-aaf6-fda09480d78d","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"4329bf0c-4a54-5d63-9354-7dd221de8490","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"b68512de-7b86-5edf-8547-d9e1103dbcf0","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"bdf354b5-bb11-5ca5-b46f-4fe625963602","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"ca70e5d9-9f49-5e98-be76-85def8989dbf","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"f4b0fec2-64a8-50c4-b32f-a4e3165b2c34","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"258fb9df-ac30-55cf-91f5-1d626b51fbc6","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"bc1f40bb-26d9-5ce5-8e40-26be0b6f4ec9","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"9edb5e98-0831-5f05-99ac-5243f5e61ed1","fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}}},{"node":{"id":"be7a2fa8-5b1e-57c0-ac68-164a29e2c50a","fields":{"slug":"/socket_option/"},"frontmatter":{"title":"Java의 Socket Option 정리"}}},{"node":{"id":"380cd3ba-df02-5eb5-bd99-dd88eee889c3","fields":{"slug":"/tomcat-connection/"},"frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?"}}},{"node":{"id":"d3f01e89-0b7e-5518-b223-4f91816fe1fb","fields":{"slug":"/spring-core-container/"},"frontmatter":{"title":"스프링으로 알아보는 IoC 컨테이너의 원리와 이해"}}},{"node":{"id":"74a04ce6-75c4-5373-8a4a-e11360c4778b","fields":{"slug":"/socket_internal/"},"frontmatter":{"title":"요청이 급증하는 상황의 Connection reset by peer 트러블 슈팅"}}},{"node":{"id":"e9743b3d-5c40-582b-ba0f-d58108c30c9a","fields":{"slug":"/mysql-transaction-lock/"},"frontmatter":{"title":"MySQL 잠금과 트랜잭션 Deep Dive"}}},{"node":{"id":"6f0905d8-70e8-531e-b3fa-a1df160991b9","fields":{"slug":"/java-synchronized/"},"frontmatter":{"title":"자바의 synchronized와 volatile"}}}]},"previous":{"fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}},"next":{"fields":{"slug":"/java-concurrency/"},"frontmatter":{"title":"Java의 동시성 프로그래밍 - overview"}}},"pageContext":{"id":"bc1f40bb-26d9-5ce5-8e40-26be0b6f4ec9","series":null,"previousPostId":"258fb9df-ac30-55cf-91f5-1d626b51fbc6","nextPostId":"a6bfa699-901e-5a77-91b6-43f20257d5ea"}},"staticQueryHashes":[],"slicesMap":{}}