{"componentChunkName":"component---src-templates-post-jsx","path":"/ch5/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"markdownRemark":{"id":"e512cc83-75e1-552a-813b-543508957e1f","excerpt":"1. 기본 방향 소스코드 최적화 분석 시 중점적으로 체크할 항목 단순 정보성 로깅을 하는 부분이 있는가? 로깅을 하지 않을 때 로깅을 위한 문자열이나 데이터가 만들어지고 있는가? 전문 파싱이나 환경설정 로딩과 같은 작업이 반복 수행되는가? 락 범위를 최소화하거나 락을 회피할 수 있는가? 집합 데이터에 대한 검색 방식은 적절한가? 문자열 처리에 오버헤드가 …","html":"<h2 id=\"1-기본-방향\" style=\"position:relative;\">1. 기본 방향<a href=\"#1-%EA%B8%B0%EB%B3%B8-%EB%B0%A9%ED%96%A5\" aria-label=\"1 기본 방향 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>\n<p>소스코드 최적화 분석 시 중점적으로 체크할 항목</p>\n<ul>\n<li>단순 정보성 로깅을 하는 부분이 있는가?</li>\n<li>로깅을 하지 않을 때 로깅을 위한 문자열이나 데이터가 만들어지고 있는가?</li>\n<li>전문 파싱이나 환경설정 로딩과 같은 작업이 반복 수행되는가?</li>\n<li>락 범위를 최소화하거나 락을 회피할 수 있는가?</li>\n<li>집합 데이터에 대한 검색 방식은 적절한가?</li>\n<li>문자열 처리에 오버헤드가 존재하는가?</li>\n<li>반복 처리 로직이 존재하는가?</li>\n<li>기능이 단순한 함수이지만 호출 횟수가 많아 성능에 영향을 미치고 있는가?</li>\n<li>영업일, 계정과목, 공통코드 같은 소량 테이블에 빈번한 조회가 발생하는가?</li>\n<li>배치 같은 경우 결과가 한정적인 데이터에 대한 반복조회가 많이 있는가?</li>\n<li>포털 화면에서 보여지는 게시물 목록 같은 것을 캐시할 수 있는가?</li>\n<li>프로그램 흐름상 병목이 존재하는가?</li>\n<li>대량건 조회는 가능한가?</li>\n<li>송수신 전문 포맷과 크기는 시스템 특성과 네트워크 환경에 적합한가?</li>\n<li>한 서비스 내에서 연계 시스템과 빈번하게 통신하는가?</li>\n</ul>\n</li>\n</ul>\n<!-- more -->\n<h2 id=\"2-불필요한-작업-제거\" style=\"position:relative;\">2. 불필요한 작업 제거<a href=\"#2-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EC%9E%91%EC%97%85-%EC%A0%9C%EA%B1%B0\" aria-label=\"2 불필요한 작업 제거 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"21-로깅\" style=\"position:relative;\">2.1 로깅<a href=\"#21-%EB%A1%9C%EA%B9%85\" aria-label=\"21 로깅 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>로그는 시스템 관리자와 개발자에게 수행된 프로그램에 대한 추가 정보를 제공하기 위해 있는 것이지 로그가 있느냐 여부가 핵심 기능에 영향을 주는 것은 아니다.</li>\n</ul>\n<h4>2.1.1 잘못 사용된 로깅 수준</h4>\n<ul>\n<li>Log4J의 경우 <code class=\"language-text\">전체(ALL)</code>, <code class=\"language-text\">추적(Trace)</code>, <code class=\"language-text\">디버그(Debug)</code>, <code class=\"language-text\">정보(info)</code>, <code class=\"language-text\">경고(Warn)</code>, <code class=\"language-text\">에러(Error)</code>, <code class=\"language-text\">심각(Fatal)</code>, <code class=\"language-text\">끄기(Off)</code>라는 8가지 수준이 제공된다.</li>\n<li>\n<p>운영 시에는 경고, 에러 수준으로 로깅을 설정한다.</p>\n<ul>\n<li>운영 시스템의 로그 수준이 디버그로 낮게 설정돼 있으면 로깅을 위한 오버헤드 코드와 파일 입출력 병목으로 응답시간이 느려질 수 있다.</li>\n</ul>\n</li>\n<li>추적이나 디버그, 정보 성격의 로그를 에러나 심각으로 남기지 않는다.</li>\n</ul>\n<h4>2.1.2 로깅을 위한 불필요한 메시지 생성</h4>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">// CASE <span class=\"token number\">1</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>int <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span> i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tLog.debug.println<span class=\"token punctuation\">(</span><span class=\"token string\">\"파일 서버에 전송할 입력 매개변수 + \"</span> + output<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n// CASE <span class=\"token number\">2</span>\n<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span>int <span class=\"token assign-left variable\">i</span><span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span>n<span class=\"token punctuation\">;</span> i++<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tif<span class=\"token punctuation\">(</span>Log.debug.isEnabled<span class=\"token punctuation\">(</span><span class=\"token punctuation\">))</span><span class=\"token punctuation\">{</span>\n\t\tLog.debug.println<span class=\"token punctuation\">(</span><span class=\"token string\">\"파일 서버에 전송할 입력 매개변수 + \"</span> + output<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">CASE 1</code>은 println 내부에서 디버그에 대한 로깅 여부를 확인해 출력하지 않아도 자바에서는 <code class=\"language-text\">“String” + Object.toString()</code> 문자열을 만드는 작업이 수행된다.</li>\n<li><code class=\"language-text\">CASE 2</code>는 <code class=\"language-text\">if(Log.debug.isEnabled())</code> 조건문으로 로깅 코드를 감싸서 로깅 수준이 비활성화 상태면 문자열을 만드는 작업이 수행되지 않는다.</li>\n</ul>\n<h4>2.1.3 로깅을 효율적으로 하기 위한 개선</h4>\n<ul>\n<li>개발 서버에 로깅하는 양이 너무 많아 원하는 로그를 찾는데 시간이 걸리고 성능 저하가 발생한다면 개발 서버도 기본 로그 수준을 경고로 설정하고, 테스트하는 구간만 디버그 수준으로 설정할 수 있다.</li>\n<li>서비스 요청 단위로 로깅을 관리하면 특정 서비스 요청만 디버그 수준으로 설정해 해당 서비스 전체의 성능 저하 없이 셀제 운영환경에서 디버그를 수행할 수 있다.</li>\n</ul>\n<h4>2.1.4 트랜잭션 저널 로그</h4>\n<h3 id=\"22-불필요한-로직\" style=\"position:relative;\">2.2 불필요한 로직<a href=\"#22-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EB%A1%9C%EC%A7%81\" aria-label=\"22 불필요한 로직 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>불필요한 로직은 공통 모듈을 사용할 때 주로 나타난다.</p>\n<ul>\n<li>대체로 공통 모듈은 다양한 경우에 대비해 여러 가지 값을 제공한다.</li>\n<li>어떤 로직에서는 필요하지 않은 정보도 함께 읽어오게 된다.</li>\n</ul>\n</li>\n<li>이를 방지하기 위해 포괄적인 정보 외에 사용 패턴을 고려해 세분화된 정보를 제공하는 함수도 다양하게 제공해야 한다.</li>\n</ul>\n<h3 id=\"23-반복-로직\" style=\"position:relative;\">2.3 반복 로직<a href=\"#23-%EB%B0%98%EB%B3%B5-%EB%A1%9C%EC%A7%81\" aria-label=\"23 반복 로직 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>성능에 영향을 주는 부분이 반복 작업으로 분석됐다면 맨 처음에 수행된 결괏값을 저장해 뒀다가 재사용할 수 있게 변수나 캐시를 둠으로써 성능 저하를 해결할 수 있다.</li>\n<li>\n<p>반복의 예</p>\n<ul>\n<li>통신전문에서 동일한 항목을 읽어내는 것임에도 파싱 작업을 한다.</li>\n<li><code class=\"language-text\">for</code>, <code class=\"language-text\">while</code> 문 안에서 매번 동일한 값으로 동일한 계산식을 수행하는 부분이 있다.</li>\n<li>외부 인터페이스를 호출할 때마다 관련 환경설정 파일을 매번 읽어 들인다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"24-불필요한-초기화-과정\" style=\"position:relative;\">2.4 불필요한 초기화 과정<a href=\"#24-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EC%B4%88%EA%B8%B0%ED%99%94-%EA%B3%BC%EC%A0%95\" aria-label=\"24 불필요한 초기화 과정 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>내부적으로 초기화 과정이 복잡하고 시간이 오래 걸리는 작업임에도 개발자 입장에서 코드를 작성하는 부분은 너무 단순해 모르고 넘어가는 경우가 있다.</p>\n<ul>\n<li>자바의 JAXB와 스프링 프레임워크의 RestTemplate등 이 있다.</li>\n</ul>\n</li>\n<li>스레드 안전한 클래스라면 싱글톤으로 선언하여 재사용할 수 있다.</li>\n<li>스레드 안전하지 않다면 ThreadLocal 같은 기능을 사용해 스레드별로 만들어 사용할 수도 있다.</li>\n</ul>\n<h2 id=\"3-로직-최적화\" style=\"position:relative;\">3. 로직 최적화<a href=\"#3-%EB%A1%9C%EC%A7%81-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"3 로직 최적화 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"31-락-최소화\" style=\"position:relative;\">3.1 락 최소화<a href=\"#31-%EB%9D%BD-%EC%B5%9C%EC%86%8C%ED%99%94\" aria-label=\"31 락 최소화 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>애플리케이션에서도 여러 프로세스나 스레드가 동일 데이터에 접근함으로써 발생할 수 있는 오류를 방지하기 위해 락을 사용한다.</li>\n<li>C/C++는 세마포어, 뮤텍스, 크리티컬 섹션 등으로 락을 제공</li>\n<li>자바는 synchronized, wait/nofity 등 제어 구문 외에도 동시성을 제어하는 클래스를 제공한다.</li>\n</ul>\n<h4>3.1.1 락 범위 최소화</h4>\n<ul>\n<li>캐시를 구성할 때 보통 데이터 종류별로 하나의 메모리 구조로 설계하는 것이 일반적이다.</li>\n<li>이 경우 해당 메모리 전체에 대해서 싱글포인트락이 존재하는 경우 동시 대량 처리 시 락 경합이 발생할 수 있으므로 복수 개의 메모리 구조로 쪼개서 락 경합을 분산할 수 있다.</li>\n</ul>\n<h4>3.1.2 락 제거</h4>\n<h3 id=\"32-문자열-처리-개선\" style=\"position:relative;\">3.2 문자열 처리 개선<a href=\"#32-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%B2%98%EB%A6%AC-%EA%B0%9C%EC%84%A0\" aria-label=\"32 문자열 처리 개선 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h4>3.2.1 String.format 메서드</h4>\n<ul>\n<li>StringBuilder 로 처리하는 것에 비해 String.format이 10배정도 느리다.</li>\n</ul>\n<h4>3.2.2 String.replaceAll 메서드</h4>\n<ul>\n<li>replaceAll 내부는 정규 표현식을 사용하는 형태로 구현돼 있어서 복잡하다.</li>\n</ul>\n<h4>3.2.3 문자열 합치기</h4>\n<ul>\n<li>자바 초기에는 “String” + 변수 + “String” 형태로 문자열을 처리하면 합치는 횟수만큼 객체가 생성되어 성능이 좋지 않았다.</li>\n<li>하지만 자바 버전이 올라가면서 컴파일러가 코드 최적화를 통해 StringBuilder로 대체하므로 개선 대상으로 고려하지 않아도 된다.</li>\n</ul>\n<h3 id=\"33-리플렉션-호출-제거\" style=\"position:relative;\">3.3 리플렉션 호출 제거<a href=\"#33-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98-%ED%98%B8%EC%B6%9C-%EC%A0%9C%EA%B1%B0\" aria-label=\"33 리플렉션 호출 제거 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>리플렉션 호출은 프로그램에 유연성과 확장성을 제공하지만 이를 구현하기 위해 객체를 생성하고 메서드를 호출하기 위한 준비 작업 하나하나가 직접 메서드를 호출하는 것과 맞먹는 비용이 든다.</li>\n</ul>\n<h3 id=\"34-채번\" style=\"position:relative;\">3.4 채번<a href=\"#34-%EC%B1%84%EB%B2%88\" aria-label=\"34 채번 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>애플리케이션 코드 내에서 채번이 이뤄지는 경우에는 성능에 큰 영향이 없으나 DB 내에서 채번이 이뤄지는 경우에는 성능 저하의 원인이 되는 경우가 많다.</li>\n<li>\n<p>DB 내 채번 방식</p>\n<ul>\n<li>기존 최대값 조회 MAX+1</li>\n<li>동시에 채번이 이뤄지는 경우 동일한 번호가 채번되어 후속 작업에서 에러가 발생할 수 있다.</li>\n<li>채번 테이블</li>\n<li>채번 테이블에 유형별 레코드로 채번 번호를 관리하는 방식</li>\n<li>DB 채번 기능</li>\n<li>DB에서 재공하는 채번 기능을 사용하는 것으로 세 가지 방식 중 가장 성능이 우수하다.</li>\n</ul>\n</li>\n<li>매번 DB에서 채번하게 되면 10,000번 채번에 DB 호출이 10,000번 수행되어야 한다.</li>\n<li>하지만 채번 테이블의 채번 캐시 크기를  예를 10,00 단위로 사용하게 되면 10,000번 채번 1번당 DB 채번이 이뤄지므로 성능이 훨등히 개선된다.</li>\n</ul>\n<h3 id=\"35-날짜-연산\" style=\"position:relative;\">3.5 날짜 연산<a href=\"#35-%EB%82%A0%EC%A7%9C-%EC%97%B0%EC%82%B0\" aria-label=\"35 날짜 연산 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"36-시간-문자열-처리\" style=\"position:relative;\">3.6 시간 문자열 처리<a href=\"#36-%EC%8B%9C%EA%B0%84-%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%B2%98%EB%A6%AC\" aria-label=\"36 시간 문자열 처리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"37-순차-검색-제거\" style=\"position:relative;\">3.7 순차 검색 제거<a href=\"#37-%EC%88%9C%EC%B0%A8-%EA%B2%80%EC%83%89-%EC%A0%9C%EA%B1%B0\" aria-label=\"37 순차 검색 제거 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"38-파일-입출력-단위\" style=\"position:relative;\">3.8 파일 입출력 단위<a href=\"#38-%ED%8C%8C%EC%9D%BC-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EB%8B%A8%EC%9C%84\" aria-label=\"38 파일 입출력 단위 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>파일 처리는 입출력 단위가 큰 것이 성능에 유리하다.</li>\n<li>버퍼를 가지고 있는 입출력 클래스를 사용해 버퍼 단위로 입출력이 발생하게 하는 편이 우수한 성능을 발휘한다.</li>\n<li><code class=\"language-text\">BufferedOutpuStream</code>, <code class=\"language-text\">BufferedInputStream</code></li>\n</ul>\n<h3 id=\"39-SQL\" style=\"position:relative;\">3.9 SQL<a href=\"#39-SQL\" aria-label=\"39 SQL permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p><strong>SQL 바인드 변수 처리</strong></p>\n<ul>\n<li>SQL을 수행할 때는 PreparedStatement 객체를 사용하여 바인드 변수 처리하는 것이 기본 원칙이다.</li>\n<li>SQL 캐시효과, 하드 파싱, 공유 풀 경합 등</li>\n<li>바인드 변수를 사용하지 않으면 필요 이상으로 많은 SQL이 공유 풀에 저장되어 메모리 사용량이 증가한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>자원 반납</strong></p>\n<ul>\n<li>SQL을 수행한 후 사용한 JDBC 자원을 반납하지 않으면 성능 저하나 장애가 유발된다.</li>\n<li>Statement를 반납하지 않으면 DB 프로세스 당 할당된 최대 커서 수에 도달해 더는 SQL을 처리할 수 없는 상황이 되고, 자바 메모리 누수 또한 발생한다.</li>\n<li>자원 반납은 ResultSet, Statement, Connection 순으로 수행한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>DB 연결 풀 사용</strong></p>\n<ul>\n<li>DB는 새로운 연결을 맺을 때 많은 비용이 드므로 일반적으로 연결 풀을 사용한다.</li>\n<li>평상시 부하는 연결을 늘리지 않고도 처리할 수 있을 정도로 최소 연결 풀 개수를 유지한다.</li>\n<li>더미 쿼리를 사용해 주기적으로 연결을 테스트함으로써 DB 연결이 방화벽이나 운영체제 설정에 의해 끊어지지 않게 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"310-BigDecimal\" style=\"position:relative;\">3.10 BigDecimal<a href=\"#310-BigDecimal\" aria-label=\"310 BigDecimal permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>float 이나 double 숫자 타입은 정확성이 아닌 성능 위주로 설계된 부동 소수 형식을 사용하기 때문에 일부 값이 정확하지 않고 근사값으로 표현된다.</li>\n<li>BigDecimal을 생성할 때 new BigDecimal(double) 보다는 new BigDecimal(String)을 사용한다.</li>\n<li>double로 변환해야 하는 경우에는 BigDecimal.valueOf(double) 메서드를 사용한다.</li>\n</ul>\n<h3 id=\"311-비대기-입출력-사용\" style=\"position:relative;\">3.11 비대기 입출력 사용<a href=\"#311-%EB%B9%84%EB%8C%80%EA%B8%B0-%EC%9E%85%EC%B6%9C%EB%A0%A5-%EC%82%AC%EC%9A%A9\" aria-label=\"311 비대기 입출력 사용 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>논블럭킹 I/O 를 사용하면 읽어내고자 하는 야보다 데이터가 적거나 전혀 없더라도 현재 있는 데이터 양만큼 읽고 나온다.</li>\n</ul>\n<h3 id=\"312-엑셀-처리\" style=\"position:relative;\">3.12 엑셀 처리<a href=\"#312-%EC%97%91%EC%85%80-%EC%B2%98%EB%A6%AC\" aria-label=\"312 엑셀 처리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>엑셀 포맷을 다룰 때 일반적으로 아파치의 POI를 사용한다.</li>\n<li>\n<p>POI는 엑셀 파일을 다룰 때 크게 스트리밍과 인 메모리 트리라는 두 가지 방식을 사용한다.</p>\n<ul>\n<li>인메모리 트리는 문서 내용 전체를 메모리에 유지하므로 메모리 사용량이 크고, 스트리밍에 비해 속도가 느리다.</li>\n</ul>\n</li>\n<li>버퍼드 스트리밍은 전체 데이터를 메모리에 가지고 있지 않고 일정 건수가 되면 디스크로 내리기 때문에 메모리 제약이 없어 큰 용량의 데이터 처리가 가능하다.</li>\n</ul>\n<h3 id=\"313-기타-성능-개선\" style=\"position:relative;\">3.13 기타 성능 개선<a href=\"#313-%EA%B8%B0%ED%83%80-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0\" aria-label=\"313 기타 성능 개선 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"314-코드-성능-측정\" style=\"position:relative;\">3.14 코드 성능 측정<a href=\"#314-%EC%BD%94%EB%93%9C-%EC%84%B1%EB%8A%A5-%EC%B8%A1%EC%A0%95\" aria-label=\"314 코드 성능 측정 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h2 id=\"4-적극적인-캐시-사용\" style=\"position:relative;\">4. 적극적인 캐시 사용<a href=\"#4-%EC%A0%81%EA%B7%B9%EC%A0%81%EC%9D%B8-%EC%BA%90%EC%8B%9C-%EC%82%AC%EC%9A%A9\" aria-label=\"4 적극적인 캐시 사용 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>성능 튜닝의 한 축은 서비스 간이나 서비스 내에서 반복되는 로직을 제거하는 것 이다.</li>\n<li>기존에 작업한 결과를 저장해 뒀다아 이후에 다시 동일한 작업이 수행됐을 때 결과를 재사용하면 반복되는 로직을 제거할 수 있다.</li>\n<li>브라우저</li>\n<li>도메인명에 대한 주소 캐시</li>\n<li>콘텐츠 캐시</li>\n<li>웹 서버</li>\n<li>환경설정 캐시</li>\n<li>콘텐츠 캐시</li>\n<li>WAS</li>\n<li>환경설정 캐시</li>\n<li>프로그램 모듈 캐시</li>\n<li>애플리케이션</li>\n<li>적극적인 사용이 요구되는 부분</li>\n<li>프레임 워크</li>\n<li>환경설정 캐시</li>\n<li>서비스와 프로그램 구성 캐시</li>\n<li>송수신 전문 구조 캐시</li>\n<li>SQL 캐시</li>\n<li>애플리케이션을 위한 캐시 제공</li>\n<li>DBMS</li>\n<li>환경설정 캐시</li>\n<li>테이블, 인덱스, 권한 등 구성정보 캐시</li>\n<li>SQL 실행계획 캐시</li>\n<li>데이터 캐시</li>\n</ul>\n<h2 id=\"5-효율적인-아키텍처-구성\" style=\"position:relative;\">5. 효율적인 아키텍처 구성<a href=\"#5-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%84%B1\" aria-label=\"5 효율적인 아키텍처 구성 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"51-병렬-처리\" style=\"position:relative;\">5.1 병렬 처리<a href=\"#51-%EB%B3%91%EB%A0%AC-%EC%B2%98%EB%A6%AC\" aria-label=\"51 병렬 처리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>웹 기반 시스템은 각 구성 서버마다 병렬 처리를 설정할 수 있다.</li>\n<li>웹 서버는 사용자의 모든 서비스 요청을 받아들이는 곳으로, 한 사용자가 6개 이상의 병렬 스레드를 사용할 수도 있다.</li>\n<li>그러나 요청이 WAS 까지 도달하면 스레드를 한두 개 사용한다.</li>\n<li>DB 동시 작업은 애플리케이션 처리시간과 DB 연결 사용시간이 거의 일치하면 스레드 풀 설정과 거의 동등한 수준으로 DB 연결 풀을 사용한다.</li>\n<li>아키텍처를 스레드 병렬 구조로 만들 때는 반드시 앞쪽에 큐를 둬서 스레드가 작압 단위 간에 쉼 없이 연속해서 처리할 수 있도록 해야한다.</li>\n</ul>\n<h3 id=\"52-통신전문\" style=\"position:relative;\">5.2 통신전문<a href=\"#52-%ED%86%B5%EC%8B%A0%EC%A0%84%EB%AC%B8\" aria-label=\"52 통신전문 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>XML의 경우에는 메모리 사용량과 전문 크기가 많다.</li>\n<li>이를 개선하기 위해 컬럼명을 레코드 첫 부분에 한번만 기술하고 이후 반복되는 레코드에서 컬럼명을 생략하고 데이터만 기술하는 변형된 형태의 JSON을 적용했다.</li>\n<li>따라서 고성능 시스템이 필요하거나 사용자가 원격지에 있어 데이터 전송량을 줄여 속도를 개선해야 하는 경우에는 다른 형식의 전문을 고려해야 한다.</li>\n</ul>\n<h3 id=\"53-고객정보-조회-이력-로깅과-마스킹\" style=\"position:relative;\">5.3 고객정보 조회 이력 로깅과 마스킹<a href=\"#53-%EA%B3%A0%EA%B0%9D%EC%A0%95%EB%B3%B4-%EC%A1%B0%ED%9A%8C-%EC%9D%B4%EB%A0%A5-%EB%A1%9C%EA%B9%85%EA%B3%BC-%EB%A7%88%EC%8A%A4%ED%82%B9\" aria-label=\"53 고객정보 조회 이력 로깅과 마스킹 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"54-대량-조회-프레임워크-구성\" style=\"position:relative;\">5.4 대량 조회 프레임워크 구성<a href=\"#54-%EB%8C%80%EB%9F%89-%EC%A1%B0%ED%9A%8C-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EA%B5%AC%EC%84%B1\" aria-label=\"54 대량 조회 프레임워크 구성 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>데이터를 대량으로 조회하다보면 메모리 부족으로 애플리케이션 서버가 다운되는 문제를 경함하게 된다.</li>\n<li>\n<p>아래와 같은 방안으로 대량건 조회를 대처할 수 있다.</p>\n<ul>\n<li>프레임워크 DAO에서 일정건이상 조회하면 예외를 발생시킨다.</li>\n<li>대량건 조회는 페이징 처리를 통해 메모리에 무리가 없는 단위로 나눠서 처리한다.</li>\n<li>대량 조회가 이뤄지지 않도록 조회 건수를 줄이는 필수 조건을 입력하도록 유도한다.</li>\n<li>일반 온라인 업무에 영향을 주지 않도록 대량 조회 전용 WAS 인스턴스를 구성한다.</li>\n<li>배치 같은 별도 프로세스에서 대량 건을 파일로 생성한 다음 파일을 다운로드하게 한다.</li>\n</ul>\n</li>\n<li>프레임워크에서 대량건 조회를 지원하기 위해서는 자바의 경우 JDBC ResultSet과 전문 생성 부분을 바로 연결해야 한다.</li>\n</ul>\n<h3 id=\"55-내부-연계시스템\" style=\"position:relative;\">5.5 내부 연계시스템<a href=\"#55-%EB%82%B4%EB%B6%80-%EC%97%B0%EA%B3%84%EC%8B%9C%EC%8A%A4%ED%85%9C\" aria-label=\"55 내부 연계시스템 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"56-수직확장과-수평확장\" style=\"position:relative;\">5.6 수직확장과 수평확장<a href=\"#56-%EC%88%98%EC%A7%81%ED%99%95%EC%9E%A5%EA%B3%BC-%EC%88%98%ED%8F%89%ED%99%95%EC%9E%A5\" aria-label=\"56 수직확장과 수평확장 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>성능 저하가 발생하면 서버를 늘리는 수평확장보다 CPU나 메모리를 증설하는 수직확장을 선호해 왔다.</p>\n<ul>\n<li>수평확장은 서버간 동기화로 인한 성능 저하가 발생할 수 있기 때문에</li>\n</ul>\n</li>\n<li>수평확장이 가능하도록 아키텍처를 구성하려면 다음과 같은 사항을 고려해야 한다.</li>\n<li>데이터베이스 샤딩</li>\n<li>샤딩은 여러 DB에 데이터를 나눠서 저장하는 기술이다.</li>\n<li>파티션은 한 DB에 분산 저장하는 것이고, 샤딩은 복수 DB에 분산 저장한다.</li>\n<li>샤딩은 DBMS가 제공하는 기능이 아니므로 애플리케이션에서 로직으로 구현해서 적용한다.</li>\n<li>DB 샤딩에서 수평확장이 용이하게 하려면 초기 샤딩 아키텍처를 설계할 때 온라인 상태에서 DB 서버를 늘리고 데이터를 옮길 수 있는 방안을 마련해야 한다.</li>\n<li>DB 서버가 4대에서 6대로 증가할 때 샤딩된 기존 저장된 DB서버를 찾아가고 증가된 DB수에 따라 데이터 재배치가 이뤄질 수 있어야 한다.</li>\n<li>DB 샤딩의 한계는 구축하기가 어렵고, 샤딩된 데이터로 인해 테이블 간에 조인이 제한적이거나 불가능하다는 것이다.</li>\n<li>대량의 데이터 처리를 고려할 때 데이터 저장 솔루션으로 고려하는 것이 NoSQL 이다.</li>\n<li>NoSQL을 이용하면 자동분할과 노드 추가 시 자동 재분배, 이중화에 의한 장애 대응까지 솔류션이 지원하므로 유연한 수평확장이 가능하다.</li>\n<li>StatelessProcessing</li>\n<li>WAS에서 세션을 통해 사용자 인증 정보를 관리하는 경우가 많다.</li>\n<li>여러 대의 WAS 서버를 사용하는 경우 세션 클러스터링 기술을 사용한다.</li>\n<li>그런데 서버 수가 많아지면 이마저도 성능 저하 요인이 된다.</li>\n<li>시스템을 Stateless 아키텍처로 만들어지면 사용자 서비스 요청이 어떤 애플리케이션 서버에서도 처리할 수 있다.</li>\n<li>인메모리 데이터 그리드</li>\n<li>인메모리 데이터 그리드는 키캆 형식의 데이터 캐시 솔류션이다.</li>\n<li>DBMS에 저장된 데이터나 사용자 서비스 호출 간에 공유할 데이터를 캐시해서 성능을 개선할 목적으로 사용한다.</li>\n<li>상대적으로 데이터의 생명주기가 짧고 변경이 발생하지 않는 데이터에 대해 캐시하는 것이다.</li>\n</ul>","frontmatter":{"title":"5부 - 소스코드 최적화","date":"February 20, 2022","update":"February 20, 2022","tags":["실무로 배우는 시스템 성능 최적화"],"series":null},"fields":{"slug":"/ch5/","readingTime":{"minutes":22.73}}},"seriesList":{"edges":[{"node":{"id":"296328f9-f83a-5280-ba4d-bd4de2c4a23a","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"c9052258-da8a-5838-97d0-5affaae34156","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"eaf68b24-edef-59b5-a7f4-4e9ea41b0321","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"522e45a7-12b4-55ae-8295-4a720f58da60","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"5413888c-b834-5d0a-a576-10b33121e612","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"b7dfee63-516c-5cf7-83bd-cfe07286f825","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"a652b497-d0e9-5d72-988a-35fb96da4202","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"142b9f9f-7ca6-5376-aa9b-55bd67d46ee3","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"440239bd-9cf3-519f-86af-72f698bb3262","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"2f0b9a48-2617-5e0a-ab00-4571b7e012c7","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"60bb268c-033b-5cdd-bba3-9351aa771fb4","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"eee5ea21-1271-510f-9b52-f5c2b8e6f8ed","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"e512cc83-75e1-552a-813b-543508957e1f","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"4db40817-9881-5aea-a6d4-b7b009c1a350","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"bb9c36ac-6d3d-53ff-891c-3d0e6d56115a","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"15e07ee1-b1da-592c-97db-c67d8a458b0c","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"00a98f1e-f4b7-562e-b052-7c7bbf333a61","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"d2b050d0-1ad6-5db3-8087-46c1ef770d5d","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"39f89aa8-d521-51b6-af7e-4f25f0648182","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"8934dee6-96ba-552c-bcd6-49294d6e7cc2","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"19fdfd91-656a-5e79-9d96-1f5a12da47ca","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"1e926a5f-341c-585c-a9ef-b00a1e1e4842","fields":{"slug":"/\benabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"3dcec820-a2a1-54a0-aaf6-fda09480d78d","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"4329bf0c-4a54-5d63-9354-7dd221de8490","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"b68512de-7b86-5edf-8547-d9e1103dbcf0","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"bdf354b5-bb11-5ca5-b46f-4fe625963602","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"ca70e5d9-9f49-5e98-be76-85def8989dbf","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"f4b0fec2-64a8-50c4-b32f-a4e3165b2c34","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"258fb9df-ac30-55cf-91f5-1d626b51fbc6","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"bc1f40bb-26d9-5ce5-8e40-26be0b6f4ec9","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"9edb5e98-0831-5f05-99ac-5243f5e61ed1","fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}}},{"node":{"id":"be7a2fa8-5b1e-57c0-ac68-164a29e2c50a","fields":{"slug":"/socket_option/"},"frontmatter":{"title":"Java의 Socket Option 정리"}}},{"node":{"id":"380cd3ba-df02-5eb5-bd99-dd88eee889c3","fields":{"slug":"/tomcat-connection/"},"frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?"}}},{"node":{"id":"d3f01e89-0b7e-5518-b223-4f91816fe1fb","fields":{"slug":"/spring-core-container/"},"frontmatter":{"title":"스프링으로 알아보는 IoC 컨테이너의 원리와 이해"}}},{"node":{"id":"74a04ce6-75c4-5373-8a4a-e11360c4778b","fields":{"slug":"/socket_internal/"},"frontmatter":{"title":"요청이 급증하는 상황의 Connection reset by peer 트러블 슈팅"}}},{"node":{"id":"e9743b3d-5c40-582b-ba0f-d58108c30c9a","fields":{"slug":"/mysql-transaction-lock/"},"frontmatter":{"title":"MySQL 잠금과 트랜잭션 Deep Dive"}}},{"node":{"id":"6f0905d8-70e8-531e-b3fa-a1df160991b9","fields":{"slug":"/java-synchronized/"},"frontmatter":{"title":"자바의 synchronized와 volatile"}}}]},"previous":{"fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}},"next":{"fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},"pageContext":{"id":"e512cc83-75e1-552a-813b-543508957e1f","series":null,"previousPostId":"eee5ea21-1271-510f-9b52-f5c2b8e6f8ed","nextPostId":"4db40817-9881-5aea-a6d4-b7b009c1a350"}},"staticQueryHashes":[],"slicesMap":{}}