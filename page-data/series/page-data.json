{"componentChunkName":"component---src-pages-series-jsx","path":"/series/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"allMarkdownRemark":{"group":[{"fieldValue":"AWS","totalCount":2},{"fieldValue":"JPA","totalCount":1},{"fieldValue":"Java","totalCount":10},{"fieldValue":"Tomcat","totalCount":2},{"fieldValue":"kernel","totalCount":1},{"fieldValue":"데이터 중심 애플리케이션 설계","totalCount":8},{"fieldValue":"데이터베이스","totalCount":2},{"fieldValue":"디자인 패턴","totalCount":3},{"fieldValue":"레디스","totalCount":1},{"fieldValue":"스프링","totalCount":5},{"fieldValue":"실무로 배우는 시스템 성능 최적화","totalCount":7},{"fieldValue":"카프카","totalCount":3}],"nodes":[{"excerpt":"메모리 아키텍처 최신 하드웨어에서의 동시 프로그래밍은 동일한 물리적 순간에 서로 다른 코어에서 여러 스레드를 동시해 실행할 수 있다.\n아래 그림2에서 이를 확인할 수 있다.\n 각 CPU는 자체 레지스터를 포함하고 있는데, 이는 CPU 내부의 메모리로 간주된다. 레지스터에 접근하고 여기에 있는 변수들에 연산을 수행하는 것은 매우 빠르다.\nCPU는 캐시 메모…","fields":{"slug":"/java-synchronized/"},"frontmatter":{"date":"December 02, 2023","update":"Dec 20, 2023","title":"자바의 synchronized와 volatile","tags":["Java"],"series":null}},{"excerpt":"잠금 엑세스 레벨 공유 잠금(Shared Locks) 공유 잠금은 다수의 쿼리가 동시에 진행될 수 있도록 허용하지만 배타적 잠금을 얻으려는 시도를 차단한다. 즉, 어떤 트랜잭션이 공유 잠금을 적용하고 있다면, 해당 데이터에 대한 쓰기 작업을 시도하는 다른 트랜잭션은 잠금이 해제될 때까지 기다려야 한다. MySQL에서는 나  같은 locking read c…","fields":{"slug":"/mysql-transaction-lock/"},"frontmatter":{"date":"November 16, 2023","update":"Nov 16, 2023","title":"MySQL 잠금과 트랜잭션 Deep Dive","tags":["데이터베이스"],"series":null}},{"excerpt":"문제 상황 소켓을 활용하여 서버-클라이언트 간 통신을 진행하는 과정에서, 클라이언트로부터의 요청이 일시적으로 급증하는 상황을 테스트하던 중,\n클라이언트 측에서  라는 예외가 간헐적으로 발생하였다. 아래는 해당 예외가 발생했을 때 클라이언트 측에서 기록된 로그이다. 는 클라이언트가 서버로부터 정상적으로 응답을 받아 출력한 메시지이다.\n그 아래에 나타나는  …","fields":{"slug":"/socket_internal/"},"frontmatter":{"date":"October 30, 2023","update":"Oct 30, 2023","title":"요청이 급증하는 상황의 Connection reset by peer 트러블 슈팅","tags":["kernel"],"series":null}},{"excerpt":"Selector Buffer 편에서도 보았듯이, java.nio 는 기존 Java I/O의 한계를 극복하기 위해서 탄생되었다. \nC/C++의 경우에는 이미 POSIX 계열 OS의 select()나 poll() 같은 시스템 호출로 멀티플렉싱을 구현하였지만 기존 Java I/O는 이를 사용할 수 없었다. Selector는 멀티플렉싱 I/O를 가능하게 한다. …","fields":{"slug":"/java-nio-selector/"},"frontmatter":{"date":"October 19, 2023","update":"Oct 19, 2023","title":"Java NIO - Selector","tags":["Java"],"series":"Java NIO"}},{"excerpt":"Channel Channel은 파일이나 소켓과 같은 엔티티 간에 데이터를 효율적으로 전송하는 통로이다.\n채널은 일반적으로 운영체제의 파일 디스크립터나 핸들러와 일대일 관계를 가진다.\n채널은 Java의 플랫폼 독립성을 유지하면서도 운영 체제의 네이티브 I/O 기능에 대한 추상화를 제공한다. 아래 그림은 Channel 클래스의 상속관계를 나타낸다.  계층구조…","fields":{"slug":"/java-nio-channel/"},"frontmatter":{"date":"October 14, 2023","update":"Oct 14, 2023","title":"Java NIO - Channel","tags":["Java"],"series":"Java NIO"}},{"excerpt":"What is Light-Weight Container? 애플리케이션 코드가 실행되는 프레임워크를 의미한다. 애플리케이션 객체(대부분 비즈니스 객체)는 컨테이너 내부에서 실행되며 컨테이너에 의해 관리된다고 한다. 다음은 경량 컨테이너가 가지는 특징들이다. 비침투성 (Non-invasiveness): 이는 애플리케이션 코드에 특별한 의존성을 부과하지 않는 …","fields":{"slug":"/spring-core-container/"},"frontmatter":{"date":"October 11, 2023","update":"Oct 11, 2023","title":"스프링으로 알아보는 IoC 컨테이너의 원리와 이해","tags":["스프링"],"series":null}},{"excerpt":"개요 지난 게시물에서는 Tomcat의 아키텍처와 클라이언트와의 연결 방식, 그리고 요청 처리 메커니즘에 대해 알아보았다.\n특히, NIO Connector의 Selector를 활용한 이벤트 루프 처리 방식은 BIO Connector에 비해 훨씬 더 많은 연결을 효율적으로 관리하면서 요청을 처리할 수 있게 만들었다. 이번 게시물에서는 Tomcat이 Selec…","fields":{"slug":"/tomcat-connection/"},"frontmatter":{"date":"October 07, 2023","update":"Oct 07, 2023","title":"Tomcat은 어떻게 Connection을 관리할까?","tags":["Tomcat"],"series":null}},{"excerpt":"버퍼 I/O 운영체제의 I/O는 모두 버퍼를 통해 이루어진다. 프로세스는 버퍼에서 데이터를 채우는 (쓰기) 또는 버퍼에 데이터를 비우는 (읽기) 작업을 운영 체제에 요청함으로써 I/O를 수행한다.\n모든 데이터는 이 메커니즘을 통해 프로세스 내부로 이동하거나 나간다.\n 위 그림에서 사용자 공간(user space)과 커널 공간(kernel space)의 개…","fields":{"slug":"/java-nio-buffer/"},"frontmatter":{"date":"October 03, 2023","update":"Oct 03, 2023","title":"Java NIO - Buffer","tags":["Java"],"series":"Java NIO"}},{"excerpt":"Socket Option 소켓 옵션은 자바의 Socket 클래스가 사용하는 네트워크 소켓이 데이터를 어떻게 보내고 받을 것인지를 결정한다. 자바에서는 클라이언트 측 소켓에 대해 9가지 옵션이 존재한다. TCP_NODELAY SO_BINDADDR SO_TIMEOUT SO_LINGER SO_SNDBUF SO_RCVBUF SO_KEEPALIVE OOBINLIN…","fields":{"slug":"/socket_option/"},"frontmatter":{"date":"September 29, 2023","update":"Sep 29, 2023","title":"Java의 Socket Option 정리","tags":["Java"],"series":null}},{"excerpt":"Jakarta EE Jakarta EE(Java EE)는 기업용 애플리케이션에 필요한 기능들의 사양을 정의해둔 명세서이다.\n즉, 대규모 애플리케이션을 개발하는데 필요한 표준화된 Java API의 모음이라고 할 수 있다.\nJava API의 특징은 API를 제공하는 구현 벤더와 분리되어 있기 때문에 API를 준수한다면 플러그 형태로 구현 벤더를 교체할 수 있…","fields":{"slug":"/tomcat/"},"frontmatter":{"date":"September 26, 2023","update":"Sep 26, 2023","title":"Apache Tomcat 이해하기(NIO Connector 중심)","tags":["Tomcat"],"series":null}},{"excerpt":"ReentrantLock 고유락(intrinsic locking, synchronized lock. monitor lock)과 달리 ReentrantLock은 폴링, 타임아웃, 인터럽트 가능한 잠금 획득을 선택할 수 있으며, 모든 잠금 및 해제 연산이 명시적이다. 아래 Lock 인터페이스는 추상적인 잠금 연산을 정의한다. ReentrantLock은 Loc…","fields":{"slug":"/java-concurrency-lock/"},"frontmatter":{"date":"September 19, 2023","update":"Sep 19, 2023","title":"Java의 동시성 프로그래밍 - Lock","tags":["Java"],"series":"Java의 동시성 프로그래밍"}},{"excerpt":"DeadLock 스레드 A각 잠금 L을 점유하고 있고 잠금 M을 획득하려고 시도하는 동시에 스레드 B가 잠금 M을 보유하고 있고 잠금 L을 획득하려고 시도하면 두 스레드는 영원히 대기하게 된다. 이러한 상황을 데드락이라고 한다. lock-ordering deadlocks 아래 코드는 leftRight(), rightLeft 메서드가 left, right …","fields":{"slug":"/java-concurrency-deadlock/"},"frontmatter":{"date":"September 18, 2023","update":"Sep 18, 2023","title":"Java의 동시성 프로그래밍 - Deadlock","tags":["Java"],"series":"Java의 동시성 프로그래밍"}},{"excerpt":"Executor Task는 논리적인 작업 단위이며, 스레드는 Task를 비동기적으로 실행할 수 있는 기술이다. Java에서는 Task 실행을 추상화하여 Executor 라는 인터페이스를 제공한다. Executor는 다양한 Task 실행 정책을 지원하는 비동기 프레임워크에 기반이 된다. Executor 구현은 통계 수집, 애플리케이션 관리 및 모니터링을 추…","fields":{"slug":"/java-concurrency-executor/"},"frontmatter":{"date":"September 17, 2023","update":"Sep 17, 2023","title":"Java의 동시성 프로그래밍 - Executor","tags":["Java"],"series":"Java의 동시성 프로그래밍"}},{"excerpt":"동시성 프로그래밍 모델 동시성은 여러 태스크가 동시에 실행된다는 시스템 속성이다. 또한 태스크들 사이에서 상호 작용을 수행할 수 있다.\n이러한 동시성은 단일 코어 프로세서부터 멀티 코어 프로세서, 다중 프로세서, 그리고 분산 시스템까지 다양한 컴퓨팅 환경에서 구현될 수 있다.\n주 목적은 사용자의 응답성을 향상시키고 처리량을 증가시키는 것이다. 동시성은 주…","fields":{"slug":"/java-concurrency-model/"},"frontmatter":{"date":"September 07, 2023","update":"Sep 07, 2023","title":"웹 서버를 위한 동시성 프로그래밍 모델","tags":["Java"],"series":"Java의 동시성 프로그래밍"}},{"excerpt":"synchronized 락의 단점 락이 걸린 객체에서 일어나는 동기화 작업은 모두 균등하게 취급된다. 락 획득/해제는 반드시 메서드 수준이나 메서드 내부의 동기화 블록 안에서 이루어져야 한다. 락을 얻지 못한 스레드는 블로킹된다. 락을 얻지 못할 경우, 락을 얻어 처리를 계속하려고 시도하는 것조차 불가능하다. 락이 걸린 데이터에 모든 연산이 동등하게 취급…","fields":{"slug":"/java-concurrency/"},"frontmatter":{"date":"August 14, 2023","update":"Aug 14, 2023","title":"Java의 동시성 프로그래밍 - overview","tags":["Java"],"series":"Java의 동시성 프로그래밍"}},{"excerpt":"Primary Key 설계의 중요성 InnoDB 기준으로 MySQL은 Primary Key를 기준으로 데이터를 클러스터링한다. \n클러스터링이라는 용어는 인접한 키 값이 있는 레코드가 물리적으로도 인접하게 저장된다는 것을 말한다.\n즉, 논리적인 PK 값에 의해 레코드의 물리적인 위치가 결정된다.\nPK값이 변경된다면 해당 레코드의 물리적인 위치도 변경된다는 …","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"date":"August 06, 2023","update":"Aug 06, 2023","title":"고성능을 위한 MySQL Primary Key 설계 전략","tags":["데이터베이스"],"series":null}},{"excerpt":"Spring Boot2 + Ehcache3 Spring Cache Abstract 와 Ehcache3 모듈 설정 방법을 알아본다. Gradle Dependency 설정 캐시 구성 Ehcache3 버전부터는 JSR-107을 자바 표준 인터페이스를 구현하였다.\n캐시에 대한 자바 표준 인터페이스를 JCache 라고 한다.\nJPA 구현체에 Hibernate 와 …","fields":{"slug":"/ehcache3/"},"frontmatter":{"date":"July 24, 2023","update":"Jul 24, 2023","title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)","tags":["스프링"],"series":null}},{"excerpt":"N+1 쿼리는 무엇을 의마하나? JPA의 한계를 설명하기 위해서는 N+1 쿼리가 발생하는 원초적인 원인에 대해 이해하는 것이 필요하다. JPA를 사용하다보면 N+1 쿼리를 경험할 수 있는데, 기술적인 방법으로 N+1 쿼리를 해결하는 게시물은 많지만, 왜 이러한 쿼리가 발생하는지에 대해 정확히 설명하는 블로그는 찾기 어렵다. 본 포스팅에서는 N+1 쿼리가 …","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"date":"July 21, 2023","update":"Jul 21, 2023","title":"JPA가 느릴 수 밖에 없는 원초적인 이유","tags":["JPA"],"series":null}},{"excerpt":"Redis Keyspace Notifications Redis에는 키 및 값의 변경 사항을 실시간으로 수신할 수 있는 Pub/Sub 기능을 제공한다. Notifications 유형 Redis 데이터 공간에 영향을 미치는 모든 작업에 대해 다음 두 가지 유형의 이벤트가 발생된다.\n예를 들어 키를 삭제하는 명령인  이 실행되면 Redis는 다음 두 가지 명령…","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"date":"July 19, 2023","update":"Jul 19, 2023","title":"Redis Keyspace Notifications에 대해 알아보자","tags":["레디스"],"series":null}},{"excerpt":"메모리 계층 구조 메모리를 필요에 따라 여러 가지 종류로 나누어 둠을 의미한다. 이떄 필요한 대부분의 경우는 CPU가 메모리에 더 빨리 접근하기 위함이다. 자주 쓰는 데이터는 계속 자주 쓰인다. 자주 쓰이는 데이터는 계속 자주 쓰이고, 자주 쓰이지 않는 데이터는 계속 자주 쓰이지 않는다. 자주 쓰이으는 데이터는 전체 데이터 양에 비해 작은 양이기 때문에,…","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"date":"July 16, 2023","update":"Jul 16, 2023","title":"Spring Cache 로 캐시 계층 구조 사용하기","tags":["스프링"],"series":null}},{"excerpt":"복잡한 Service 계층 Service 계층은 애플리케이션의 핵심 비즈니스 로직을 수행하는 중심적인 역할을 한다.\n이 계층은 데이터 유효성 검증, 복잡한 계산 로직, 데이터베이스 CRUD 연산, 외부 API 통신, 그리고 트랜잭션 관리까지 다양한 책임을 지니고 있다.\n실무에서 코드를 파악할 일이나 유지보수할 일이 생기면 가장 먼저 찾고 코드를 보는데 많…","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"date":"June 23, 2023","update":"Jun 23, 2023","title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 ","tags":["스프링"],"series":null}},{"excerpt":"1. 개요 일반적으로 Spring 환경에서 Amazon SQS 라이브러리로  모듈을 사용합니다.  을 분석하고, 단점을 보완한 모듈을 설계하는 것을 목표로 합니다. 2. Spring Cloud AWS Messaging 모듈  모듈을 사용하면 를 추상화한 API를 사용해 쉽게 와 를 구현할 수 있습니다. 아래와 같이 간단한 설정만으로 Consumer의 경우…","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"date":"June 20, 2023","update":"Jun 20, 2023","title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝","tags":["AWS"],"series":null}},{"excerpt":"대기열 유형 표준 대기열(Standard) 무제한 처리량 : API 작업당 거의 무제한의 TPS를 지원 최소한 한 번 전달(At-least-once delivery) : 메시가 최소한 한 번 전달되고, 가끔 2개 이상의 메시지 복사본이 전달될 수 있다. 순서 보장을 위해 최선의 노력 : 가끔 메시지가 전송된 순서와 다르게 전달될 수 있음.  FIFO 대기…","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"date":"June 19, 2023","update":"Jun 19, 2023","title":"Amazon SQS 딥다이브","tags":["AWS"],"series":null}},{"excerpt":"카프카 스트림즈란? 사용자가 Kafka에서 데이터를 실시간으로 처리하는 상태 저장 스트림 처리 애플리케이션을 구축할 수 있게 해준다.\nStreams API로 개발된 애플리케이션은 이벤트 시간(즉, 데이터가 실제로 현실 세계에서 생성된 시점)을 기준으로 실시간 스트리밍 데이터를 처리하며, 늦게 도착하는 레코드도 지원한다.\n이를 통해 데이터 처리를 신속하게 …","fields":{"slug":"/enabling_exactly_once_kafka_streams/"},"frontmatter":{"date":"June 16, 2023","update":"Jun 16, 2023","title":"카프카 스트림즈의 정확히 한 번","tags":["카프카"],"series":null}},{"excerpt":"왜 트랜잭션인가? 웹 페이지 노출 스트림을 소비하고 웹 페이지당 총 조회 수를 생성하는 애플리케이션은 카운트에서 약간의 오류를 허용할 수 있다.\n그러나 이러한 애플리케이션의 인기와 함께 더 강력한 의미론을 갖춘 스트림 처리 애플리케이션에 대한 수요도 증가했다.\n예를 들어, 일부 금융 기관에서는 스트림 처리 애플리케이션을 사용하여 사용자 계정의 차변 및 대…","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"date":"June 15, 2023","update":"Jun 15, 2023","title":"카프카에서의 Transactions","tags":["카프카"],"series":null}},{"excerpt":"Message Delivery Semantics 분산형 Pub/Sub 메시징 시스템에서는 컴퓨터들이 독립적으로 장애를 일으킬 수 있다.\n예를 들어, 카프카는 개별 브로커 충돌이나 프로듀서가 메시지를 보내는 동안 네트워크 장애로 인해 문제가 발생할 수 있다.\n이러한 장애를 처리하기 위해 프로듀서가 취하는 조치에 따라 다른 의미가 있다. At most onc…","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"date":"June 14, 2023","update":"Jun 14, 2023","title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?","tags":["카프카"],"series":null}},{"excerpt":"팩토리 패턴 구상 클래스의 인스턴스 생성 부분을 캡슐화하기 피자 인스턴스를 만드는 구상 클래스를 선택하는 부분이 상황이 변하면 코드를 변경해야 한다. 객체 생성 부분 캡슐화 하기 피자 인스턴스 생성 부분을 SimplePizzaFactory로 넘겼을 때의 장점은? 팩토리를 사용하지 않으면 피자 인스턴스를 생성하는 부분이 많아 생성하는 작업이 변경되었을 때 …","fields":{"slug":"/create/"},"frontmatter":{"date":"April 10, 2022","update":"Apr 10, 2022","title":"디자인 패턴 - 생성 패턴","tags":["디자인 패턴"],"series":null}},{"excerpt":"데코레이터 패턴 OCP 살펴보기 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다. 기존 코드를 변경하지 않아도 확장할 수 있어야 한다. 옵저버 패턴을 예로 들면 옵저버를 새로 추가하면 주제에 코드를 추가하지 않으면서도 얼마든지 확장이 가능하다. 모든 부분에서 OCP를 준수해야 하는가? 현실적으로도 불가능하고 OCP를 지키다 보면 추상화가 …","fields":{"slug":"/struct/"},"frontmatter":{"date":"April 07, 2022","update":"Apr 07, 2022","title":"디자인 패턴 - 구조 패턴","tags":["디자인 패턴"],"series":null}},{"excerpt":"디자인 패턴- 행동 패턴 어떤 처리의 책임을 어느 객체에 할당하는 것이 좋은지, 알고리즘은 어느 객체에 정의하는 것이 좋은지 다룹니다. 객체들 간의 교류 방법에 대하여 정의한다. 행동 클래스 패턴 은 클래스 사이에 행동 책임을 분산하기 위해서 상속을 사용합니다. 행동 객체 패턴 은 상속보다는 복합을 통해서 객체 사이에 행동처리의 책임을 분산합니다. 전략 …","fields":{"slug":"/behavior/"},"frontmatter":{"date":"April 02, 2022","update":"Apr 02, 2022","title":"디자인 패턴 - 행동 패턴","tags":["디자인 패턴"],"series":null}},{"excerpt":"@EnableAutoConfiguration Spring Boot 애플리케이션이 시작되면 spring-boot-autoconfigure 모듈에 미리 정의된 Configuration 클래스들이 자동으로 구성됩니다. (스프링 부트 자동 구성 목록) Auto Configuration이 실제 실행되는지 여부는 클래스 경로에 종속 클래스가 있는지 여부에 따라 달라…","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"date":"March 28, 2022","update":"Mar 28, 2022","title":"SpringBoot AutoConfiguration 시작하기","tags":["스프링"],"series":null}},{"excerpt":"1. 기본 방향 프로그램 단위에서 접근하는 경우 아래의 6가지 접근법만 이해하면 여러 성능 개선 항목을 도출할 수 있다. 중복 수행 제거 불필요한 수행 제거 최적 수행 필요 이상으로 많은 데이터 건수를 조회하는가? 조회한 항목은 다 사용하는 값인가? 조회하는 항목은 모두 사용자에게 보여줘야 하는가? 업므 데이터의 성격상 쿼리를 개선할 부분이 있는가? 데이…","fields":{"slug":"/ch7/"},"frontmatter":{"date":"March 16, 2022","update":"Mar 16, 2022","title":"7부 - 애플리케이션 입장에서의 SQL 튜닝","tags":["실무로 배우는 시스템 성능 최적화"],"series":null}},{"excerpt":"1. 기본 방향 SQL 튜닝 시 중점적으로 점검할 항목 통계 최적 실행계획이 수립되도록 테이블 통계 정보가 존재하고 주기적으로 갱신되는가? 인덱스 적절한 인덱스를 사용하는가? 인덱스가 있음에도 사용하지 못하는가? 인덱스 수가 많아서 INSERT 처리 시간이 오래걸리는가? 조인 처리하는 데이터 양과 연결 관계에 맞는 조인 방식이 선정됐는가? 조인 관계에서 …","fields":{"slug":"/ch6/"},"frontmatter":{"date":"March 13, 2022","update":"Mar 13, 2022","title":"6부 - SQL 최적화","tags":["실무로 배우는 시스템 성능 최적화"],"series":null}},{"excerpt":"1. 기본 방향 소스코드 최적화 분석 시 중점적으로 체크할 항목 단순 정보성 로깅을 하는 부분이 있는가? 로깅을 하지 않을 때 로깅을 위한 문자열이나 데이터가 만들어지고 있는가? 전문 파싱이나 환경설정 로딩과 같은 작업이 반복 수행되는가? 락 범위를 최소화하거나 락을 회피할 수 있는가? 집합 데이터에 대한 검색 방식은 적절한가? 문자열 처리에 오버헤드가 …","fields":{"slug":"/ch5/"},"frontmatter":{"date":"February 20, 2022","update":"Feb 20, 2022","title":"5부 - 소스코드 최적화","tags":["실무로 배우는 시스템 성능 최적화"],"series":null}},{"excerpt":"4부 - 프로세스 이해하기 1. 기본 방향 애플리케이션 최적화를 하기 위해서 프로세스의 동작 방식을 이해해야 한다. 프로세스 이해에 필요한 기본 지식으로 다음 세 가지가 있다. 수행 중인 코드 : 프로세스가 현재 어떤 함수를 수행하고 있는가? 통신/파일 상태 : 프로세스가 통신으로 연계된 서버는 어디고, 어떤 파일을 열고 있는가? 통신/파일 간 동작 상태…","fields":{"slug":"/ch4/"},"frontmatter":{"date":"February 08, 2022","update":"Feb 08, 2022","title":"4부 - 프로세스 이해하기","tags":["실무로 배우는 시스템 성능 최적화"],"series":null}},{"excerpt":"1. 기본 방향 2. HTTP의 이해 2.1 프로토콜 구조 기본적으로 클라이언트 서버 간에 요청과 응답이 1:1 구조를 띠고 있다. HTTP 요청/응답 모두 헤더와 본문으로 구성돼 있다. 2.2 HTTP 요청 요청은 헤더와 본문으로 나뉘고, 헤더는 다시 요청 라인과 MIME 헤더로 나뉜다. 요청 헤더 요청 방식으로는 8가지가 있다. , , , , , , …","fields":{"slug":"/ch3/"},"frontmatter":{"date":"February 05, 2022","update":"Feb 05, 2022","title":"3부 - 화면 응답시간 분석","tags":["실무로 배우는 시스템 성능 최적화"],"series":null}},{"excerpt":"1장. 기본 자세 적극적이고 도전적인 자세를 갖춰라 다른 사람의 설명과 의견에 귀 기울여라 종합적인 시각을 가져라 실행하고 비교하라 2장. 성능 분석 시작하기 클라이언트부터 시작해 웹 서버, 애플리케이션 서버, DB 서버 등 여러 서버를 거쳐서 동작한다. 이런 구성에서 성능 저하가 발생했을 땐 네트워크를 기준으로 각 서버가 전체 응답시간에서 차지하는 비중…","fields":{"slug":"/ch2/"},"frontmatter":{"date":"February 04, 2022","update":"Feb 04, 2022","title":"2부 - 성능 개선","tags":["실무로 배우는 시스템 성능 최적화"],"series":null}},{"excerpt":"1. 성능이란? 고객의 특정 업무를 대상으로 운영환경하에서 고객이 수긍할 수 있는 응답시간 내에 처리할 수 있는 거래량이라고 정의할 수 있다. 1.1 동시 사용자 성능 테스트나 운영 시 시스템에 발생하는 부하의 의미로 많이 사용되는 용어가 바로 동시 사용자다. 동시 사용자에 대한 정의는 개발자와 업무담당자간에 다르게 해석할 수 있다. 동시에 시스템에 트랜…","fields":{"slug":"/ch1/"},"frontmatter":{"date":"February 03, 2022","update":"Feb 03, 2022","title":"1부 - 성능 기초","tags":["실무로 배우는 시스템 성능 최적화"],"series":null}},{"excerpt":"분산 시스템을 다루는 것은 한 컴퓨터에서 실행되는 소프트웨어를 작성하는 일과는 다르다. 뭔가 잘못될 수 있고 새롭고 흥미진진한 방법이 많다는 점이다. 이번장은 분산 시스템에서 잘못될지도 모르는 것에 관한 개요이다. 결함과 부분 장애 단일 컴퓨터에서 실행되는 소프트웨어는 하드웨어가 올바르게 동작하면 같은 연산은 항상 같은 결과를 낸다. 좋은 소프트웨어가 설…","fields":{"slug":"/ch8/"},"frontmatter":{"date":"February 02, 2022","update":"Feb 02, 2022","title":"8장 - 분산 시스템의 골칫거리","tags":["데이터 중심 애플리케이션 설계"],"series":null}},{"excerpt":"애매모호한 트랜잭션의 개념 ACID의 의미 트랜잭션이 제공하는 안정성 보장은 원자성(Atomicity), 일관성(Consistency), 격리성(Isolation), 지속성(Durability) 을 의미하는  로 잘 알려져 있다. 그러나 현실에서는 데이터베이스마다 ACID 구현이 재각각이다. 시스템에서 실제로 어떤 것을 기대할 수 있는지 분명하지 않다. …","fields":{"slug":"/ch7/"},"frontmatter":{"date":"February 01, 2022","update":"Feb 01, 2022","title":"7장 - 트랜잭션","tags":["데이터 중심 애플리케이션 설계"],"series":null}},{"excerpt":"파티셔닝과 복제 데이터셋이 매우 크거나 질의 처리량이 매우 높다면 복제만으로 부족하고 데이터를 파티션으로 쪼갤 필요가 있다. 이 작업을 이라고 한다. 파티션을 나눌 때는 보통 각 데이터 단위(레코드, 로우, 문서)가 하나의 파티션에 속하게 한다. 데이터 파티셔닝을 원하는 주된 이유는 확장성이다. 보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여…","fields":{"slug":"/ch6/"},"frontmatter":{"date":"January 28, 2022","update":"Jan 28, 2022","title":"6장 - 파티셔닝","tags":["데이터 중심 애플리케이션 설계"],"series":null}},{"excerpt":"복제 란 네트워크로 연결된 여러 장비에 동일한 데이터 복사본을 유지한다는 의미이다. 데이터 복제가 필요한 이유는 다음과 같다. 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다. 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다. 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다. 복제에서 모든 어려움…","fields":{"slug":"/ch5/"},"frontmatter":{"date":"January 23, 2022","update":"Jan 23, 2022","title":"5장 - 복제","tags":["데이터 중심 애플리케이션 설계"],"series":null}},{"excerpt":"데이터 타입이나 스키마가 변경될 때 애플리케이션 코드에 대한 변경이 종종 발생한다. 하지만 대규모 애플리케이션에서 코드 변경은 대게 즉시 반영할 수 없다. 서버 측 애플리케이션에서는 한 번에 몇 개의 노드에 새 버전을 배포하고 새로운 버전이 원할하게 실행되는지 확인한 다음 서서히 모든 노드에서 실행되게 하는 방식이 있다. 클라이언트 측 애플리케이션은 사용…","fields":{"slug":"/ch4/"},"frontmatter":{"date":"January 18, 2022","update":"Jan 18, 2022","title":"4장 - 부호화와 발전","tags":["데이터 중심 애플리케이션 설계"],"series":null}},{"excerpt":"데이터베이스를 강력하게 만드는 데이터 구조 일반적으로 파일 추가 작업은 매우 효율적이기 때문에 로그(log)를 기록할 때 파일을 사용한다. 하지만 파일에서 특정 로그키를 찾을 때마다  만큼 걸리기 때문에 성능이 매우 좋지 않다. 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 가 필요하다. 색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하…","fields":{"slug":"/ch3/"},"frontmatter":{"date":"January 14, 2022","update":"Jan 14, 2022","title":"3장 - 저장소와 검색","tags":["데이터 중심 애플리케이션 설계"],"series":null}},{"excerpt":"데이터  모델은 소프트웨어가 할 수 있는 일과 할 수 없는 일에 지대한 영향을 주므로 애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다. 관계형 모델과 문서 모델 오늘날 가장 장 알려진 데이터 모델은 관계형 모델을 기반으로 한 SQL 이다. 데이터는 관계(relation) 로 구성되고 각 관계는 순서 없는 튜플(tuple) 의 모음이다.…","fields":{"slug":"/ch2/"},"frontmatter":{"date":"January 10, 2022","update":"Jan 10, 2022","title":"2장 - 데이터 모델과 질의 언어","tags":["데이터 중심 애플리케이션 설계"],"series":null}},{"excerpt":"일반적으로 데이터 중심 애플리케이션은 다음을 필요로 한다. 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장 (데이터베이스) 읽기 속도 향상을 위해 값비싼 수행결과를 기억 (캐시) 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링 할 수 있게 제공 (검색 색인, search Index) 비동기 처리를 …","fields":{"slug":"/ch1/"},"frontmatter":{"date":"January 05, 2022","update":"Jan 05, 2022","title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션","tags":["데이터 중심 애플리케이션 설계"],"series":null}}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}