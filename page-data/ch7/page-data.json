{"componentChunkName":"component---src-templates-post-jsx","path":"/ch7/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"markdownRemark":{"id":"bb9c36ac-6d3d-53ff-891c-3d0e6d56115a","excerpt":"1. 기본 방향 프로그램 단위에서 접근하는 경우 아래의 6가지 접근법만 이해하면 여러 성능 개선 항목을 도출할 수 있다. 중복 수행 제거 불필요한 수행 제거 최적 수행 필요 이상으로 많은 데이터 건수를 조회하는가? 조회한 항목은 다 사용하는 값인가? 조회하는 항목은 모두 사용자에게 보여줘야 하는가? 업므 데이터의 성격상 쿼리를 개선할 부분이 있는가? 데이…","html":"<h2 id=\"1-기본-방향\" style=\"position:relative;\">1. 기본 방향<a href=\"#1-%EA%B8%B0%EB%B3%B8-%EB%B0%A9%ED%96%A5\" aria-label=\"1 기본 방향 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>\n<p>프로그램 단위에서 접근하는 경우 아래의 6가지 접근법만 이해하면 여러 성능 개선 항목을 도출할 수 있다.</p>\n<ul>\n<li>중복 수행 제거</li>\n<li>불필요한 수행 제거</li>\n<li>최적 수행</li>\n<li>필요 이상으로 많은 데이터 건수를 조회하는가?</li>\n<li>조회한 항목은 다 사용하는 값인가?</li>\n<li>조회하는 항목은 모두 사용자에게 보여줘야 하는가?</li>\n<li>업므 데이터의 성격상 쿼리를 개선할 부분이 있는가?</li>\n<li>데이터 검색 범위는 적절한가?</li>\n<li>수행 통합</li>\n<li>주종 관계로 수행되는 쿼리를 한 개의 쿼리로 통합할 수 있는가?</li>\n<li>상관관계는 없으나 DB 호출을 줄이기 위해 쿼리를 합칠 수 있는가?</li>\n<li>집합 처리</li>\n<li>여러 건 처리 시 입력/수정/삭제를 건별로 처리하고 있는가?</li>\n<li>데이터 처리 단위는 적절한가?</li>\n<li>트랜잭션 처리</li>\n</ul>\n</li>\n</ul>\n<!-- more -->\n<h2 id=\"2-중복-SQL-수행-제거\" style=\"position:relative;\">2. 중복 SQL 수행 제거<a href=\"#2-%EC%A4%91%EB%B3%B5-SQL-%EC%88%98%ED%96%89-%EC%A0%9C%EA%B1%B0\" aria-label=\"2 중복 SQL 수행 제거 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>CBC(Component Based Developmnet) 기반 개발이 보편화되어 재활용성과 유지보성은 좋아졌지만 기초 정보가 동일한 조건으로 반복적으로 호출되는 경우가 빈번하게 발생한다.</li>\n<li>\n<p><strong>빈번한 유효성 검증</strong></p>\n<ul>\n<li>컴포넌트 단위로 안정성과 정합성이 유지될 수 있도록 모듈 단위로 입력 값에 검증을 추가로 수행하는 것이 일반화되어 검증이 반복적으로 수행된다.</li>\n</ul>\n</li>\n<li>\n<p>동일 SQL/모듈의 반복 호출</p>\n<ul>\n<li>상부와 하부 컴포너트 간 호출 빈도나 쓰임새를 고려하지 않고 모든 컴포넌트가 동일한 방식으로 개발되어 SQL/모듈이 한 프로그램 내에서 많게는 수십에서 수천 까지 반복 호출되는 문제를 유발한다.</li>\n</ul>\n</li>\n<li>\n<p>불필요한 기능 수행</p>\n<ul>\n<li>모듈이 범용화되는 과정을 거치게 되는데, 이로 인해 한 모듈이 여러 서비스에서 필요로 하는 다양한 정보를 제공하려는 경향이 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"21-애플리케이션-캐시의-종류\" style=\"position:relative;\">2.1 애플리케이션 캐시의 종류<a href=\"#21-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BA%90%EC%8B%9C%EC%9D%98-%EC%A2%85%EB%A5%98\" aria-label=\"21 애플리케이션 캐시의 종류 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h4>2.1.1 블록 캐시</h4>\n<ul>\n<li>블록 캐시는 애플리케이션의 특정 블록(함수) 내에서 SQL 중복 수행을 제거하나 처리 결과 중간 값을 저장하는 등의 목적으로 사용하는 캐시다.</li>\n<li>데이터 저장소가 함수 내 로컬 변수로 선언되어 해당 블록 내에서만 유효하다는 특징이 있다.</li>\n<li>특정 함수 내에서 for/while 문으로 여러 개의 데이터를 처리할 때 유용하다.</li>\n<li>저바의 경우 데이터 저장소로 HashMap을 많이 사용한다.</li>\n<li>필요할 때마다 건별로 조회하지 않고 필요 데이터를 한 번에 캐시를 만든 후 while이나 for 문 안에서 참조할 때 캐시에서 찾음으로써 DB 호출을 제거한다.</li>\n</ul>\n<h4>2.1.2 요청 캐시</h4>\n<ul>\n<li>요청 캐시는 사용자 요청 서비스가 시작되어 종료될 때까지 유지되는 캐시다.</li>\n<li>서비스 요청이 들어와 애플리케이션이 시작될 때 캐시가 초기화되어 비어 있고 애플리케이션이 종료될 때 캐시가 지워져 사라지는 구조로 사용자 서비스 간에는 데이터가 공유되지 않는다.</li>\n<li>자바의 경우 캐시가 ThreadLocal이나 서비스 컨텍스트에 위치하게 한다.</li>\n<li>서비스 시작과 종료 시 캐시가 프레임워크에서 자동으로 초기화 및 삭제된다.</li>\n<li>고객관리 시스템에서는 고객 기본정보 조회가 한 서비스 내에서 반복 호출되는 경우가 있는데 기존에 조회된 데이터가 없으면 DB를 조회해 캐시한 후 내보내고, 이미 조회된 데이터가 있으면 캐시된 데이터를 내보낸다.</li>\n</ul>\n<h4>2.1.3 사용자 세션 캐시</h4>\n<ul>\n<li>시스템에 접속한 사용자 세션 단위로 캐시를 가지는 구조로서, 접속한 사용자에 대한 기초 데이터를 보관해서 DB 조회를 최소화하는 방식이다</li>\n</ul>\n<h4>2.1.4 프로세스 캐시</h4>\n<ul>\n<li>WAS 인터턴스 단위 내에서 공유되는 식으로 프로세스 내에서 처리되는 모든 서비스 요청이 캐시를 공유해서 사용한다.</li>\n<li>프로세스 단위로 공유되므로 자바의 싱글턴 구조로 구현된다.</li>\n<li>빈번하게 사용되는 코드성 테이블에 대한 DB 조회를 최소화하기 위해 많이 사용된다.</li>\n</ul>\n<h4>2.1.5 프로세스간 공유 캐시</h4>\n<ul>\n<li>프로세스 단위로 캐시를 구성하는 경우 시스템 전체로 봤을 때 동일한 데이터가 여러 개의 프로세스에 캐시되어 메모리 중복 손실이 발생하고, 힙을 대량으로 사용하면 GC에 악영향을 미치게 된다.</li>\n<li>자바 메모리의 한계를 극보하기 위해 메모리 캐시 전용 솔류션이 사용되고 있는데 대표적으로 Redis가 있다.</li>\n</ul>\n<h4>2.1.6 캐시 특성 분류</h4>\n<h3 id=\"22-요청-캐시-구현\" style=\"position:relative;\">2.2 요청 캐시 구현<a href=\"#22-%EC%9A%94%EC%B2%AD-%EC%BA%90%EC%8B%9C-%EA%B5%AC%ED%98%84\" aria-label=\"22 요청 캐시 구현 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"23-캐시-적용\" style=\"position:relative;\">2.3 캐시 적용<a href=\"#23-%EC%BA%90%EC%8B%9C-%EC%A0%81%EC%9A%A9\" aria-label=\"23 캐시 적용 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h2 id=\"3-불필요한-SQL-수행-제거\" style=\"position:relative;\">3. 불필요한 SQL 수행 제거<a href=\"#3-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-SQL-%EC%88%98%ED%96%89-%EC%A0%9C%EA%B1%B0\" aria-label=\"3 불필요한 SQL 수행 제거 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>\n<p>공통 모듈을 사용하거나 서로 다른 개발자가 개발한 모듈을 사용한 애플리케이션의 경우 로직과 수행 SQL은 최적화가 안되는 경우가 많다.</p>\n<ul>\n<li>특정 컬럼만 조회하면 되지만 공통 모듈의 무거운 쿼리를 사용해서 조회하는 경우</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-최적-수행\" style=\"position:relative;\">4. 최적 수행<a href=\"#4-%EC%B5%9C%EC%A0%81-%EC%88%98%ED%96%89\" aria-label=\"4 최적 수행 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"41-Rownum-추가\" style=\"position:relative;\">4.1 Rownum 추가<a href=\"#41-Rownum-%EC%B6%94%EA%B0%80\" aria-label=\"41 Rownum 추가 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>DB에는 한 번에 보내는 레코드 건수를 설정할 수 있는데 이를 Fetch 크기라고 한다.</li>\n<li>Fetch size가 크면 DB와 애플리케이션 간의 턴을 줄일 수 있지만, 필요한 데이터보다 더 많은 데이터를 가져올 수 있다.</li>\n</ul>\n<h3 id=\"42-파티션-키-추가\" style=\"position:relative;\">4.2 파티션 키 추가<a href=\"#42-%ED%8C%8C%ED%8B%B0%EC%85%98-%ED%82%A4-%EC%B6%94%EA%B0%80\" aria-label=\"42 파티션 키 추가 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>파티션 테이블은 배치 메인 쿼리의 경우 전체 테이블 탐색 범위를 줄이기 위해 사용하고 입력에서는 부하분산 등 성능 목적으로 사용하며, 대량 데이터를 관리하는 목적으로 주로 사용한다.</li>\n<li>파티션 테이블이 글로벌 인덱스를 사용하는 경우 주기적으로 보관연한이 지난 파티션을 제거하게 되면 글로벌 인데그삭 사용불가 상태로 바뀐다.</li>\n<li>이 같은 상황을 방지하기 위해 파티션 테이블을 사용할 때는 가급적 로컬 인덱스를 사용하는 것을 기본으로 하고, 단지 로컬 인덱스로 성능 목표를 달성하지 못하는 경우에만 글로벌 인덱스를 사용하는 것을 고려한다.</li>\n<li>파티션 키가 Where 조건에 없다면 모든 파티션 테이블을 순차적으로 조회하는 것과 동일한 성능 저하가 발생할 수 있으므로 어떤 식으로든 파티션 키가 Where 조건에 포함될 수 있게 한다.</li>\n</ul>\n<h3 id=\"43-조회-항목-사용-여부테이블-조인-제거\" style=\"position:relative;\">4.3 조회 항목 사용 여부(테이블 조인 제거)<a href=\"#43-%EC%A1%B0%ED%9A%8C-%ED%95%AD%EB%AA%A9-%EC%82%AC%EC%9A%A9-%EC%97%AC%EB%B6%80%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%A1%B0%EC%9D%B8-%EC%A0%9C%EA%B1%B0\" aria-label=\"43 조회 항목 사용 여부테이블 조인 제거 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>공통으로 사용하는 쿼리는 최대한 많은 컬럼을 조회해서 제공하려 한다.</li>\n<li>조회하는 컬럼을 줄이는 것도 의미가 있지만 테이블의 조인을 제거하것도 효과적이다.</li>\n</ul>\n<h2 id=\"5-쿼리-통합\" style=\"position:relative;\">5. 쿼리 통합<a href=\"#5-%EC%BF%BC%EB%A6%AC-%ED%86%B5%ED%95%A9\" aria-label=\"5 쿼리 통합 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>쿼리 통합은 Select에 대한 집합 처리를 의미한다.</li>\n<li>여러 번 수행하는 쿼리를 한 번에 수행해 성능을 개선하는 것이다.</li>\n</ul>\n<h3 id=\"51-메인서브-쿼리\" style=\"position:relative;\">5.1 메인/서브 쿼리<a href=\"#51-%EB%A9%94%EC%9D%B8%EC%84%9C%EB%B8%8C-%EC%BF%BC%EB%A6%AC\" aria-label=\"51 메인서브 쿼리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h3 id=\"52-병렬-쿼리-통합\" style=\"position:relative;\">5.2 병렬 쿼리 통합<a href=\"#52-%EB%B3%91%EB%A0%AC-%EC%BF%BC%EB%A6%AC-%ED%86%B5%ED%95%A9\" aria-label=\"52 병렬 쿼리 통합 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>고객 통합정보 조회 하면을 떠올려 보자.</p>\n<ul>\n<li>기본정보, 결제이력, 카드 보유 개수, 마케팅 대상 등등..</li>\n<li>20~30개의 쿼리가 순차적으로 수행되는 구조가 된다.</li>\n</ul>\n</li>\n<li>이런 경우에는 Union all이나 일대일 조인 형태로 하나의 쿼리로 통합하면 DB 호출 횟수가 줄어들어 성능 개선이 가능하다.</li>\n</ul>\n<h2 id=\"6-DB-집합-처리\" style=\"position:relative;\">6. DB 집합 처리<a href=\"#6-DB-%EC%A7%91%ED%95%A9-%EC%B2%98%EB%A6%AC\" aria-label=\"6 DB 집합 처리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>10건의 데이터를 개별적으로 입력한다면 애플리케이션 서버와 DB 서버 간 애플리케이션 턴도 10회 생기고 SQL 실행과 결과도 10회 발생한다.</li>\n<li>\n<p>집합 처리는 애플리케이션 턴 1회에 10건의 데이터를 모두 전송함으로서 성능 개선 효과가 있다.</p>\n<ul>\n<li>단건 처리 (<code class=\"language-text\">PreparedStatement.excuteUpdate()</code>)</li>\n<li>집합 처리 (<code class=\"language-text\">PreparedStatement.addBatch()</code>,<code class=\"language-text\">PreparedStatement.executeBatch()</code>)</li>\n</ul>\n</li>\n<li>집합 처리를 수행할 때 수십만 건씩 처리하면 자바 힙 메모리가 부족해지는 현상이 발생해지므로 최대 만 건 이내로, 일반적으로는 천 건 단위로 수행한다.</li>\n</ul>\n<h2 id=\"7-트랜잭션-처리\" style=\"position:relative;\">7. 트랜잭션 처리<a href=\"#7-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%B2%98%EB%A6%AC\" aria-label=\"7 트랜잭션 처리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>동일한 레코드를 Update 하는 서비스가 있다고 할 때, Update 문의 위치가 응답시간에 영향을 미친다.</li>\n<li>락을 흭득하는 위치가 트랜잭션 중간이면 다른 트랜잭션이 락을 대기하는 시간이 늘어나기 때문에 트랜잭션의 마지막에 위치하는게 좋다.</li>\n</ul>\n<h2 id=\"8-기타\" style=\"position:relative;\">8. 기타<a href=\"#8-%EA%B8%B0%ED%83%80\" aria-label=\"8 기타 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<h3 id=\"81-복합적인-기능을-수행하는-쿼리-제거\" style=\"position:relative;\">8.1 복합적인 기능을 수행하는 쿼리 제거<a href=\"#81-%EB%B3%B5%ED%95%A9%EC%A0%81%EC%9D%B8-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EC%88%98%ED%96%89%ED%95%98%EB%8A%94-%EC%BF%BC%EB%A6%AC-%EC%A0%9C%EA%B1%B0\" aria-label=\"81 복합적인 기능을 수행하는 쿼리 제거 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>복합 기능 쿼리란 하나의 쿼리에 1개 이상의 기능이 담긴 쿼리를 말한다.</li>\n<li>복합 기능 쿼리에서 성능 저하가 발생하는 이유는 DB에서 쿼리가 바인드 변수 값에 따라 실행될 때마다 실행계획을 수립하는 것이 아니라 최초 실행 시 실행계획을 수립하고 이후에는 기존 실행계획을 재사용하기 때문이다.</li>\n<li>쿼리 한 개는 한 개의 실행계획만 가지고 있어 다양한 입력 조건에 맞게 실행계획을 수립할 수 없다.</li>\n<li>Union all 을 이용해서 쿼리를 분리하면 하나의 실행계획으로 안정적인 성능을 기대할 수 있다.</li>\n</ul>\n<h3 id=\"82-스칼라-서브-쿼리-사용-시-주의사항\" style=\"position:relative;\">8.2 스칼라 서브 쿼리 사용 시 주의사항<a href=\"#82-%EC%8A%A4%EC%B9%BC%EB%9D%BC-%EC%84%9C%EB%B8%8C-%EC%BF%BC%EB%A6%AC-%EC%82%AC%EC%9A%A9-%EC%8B%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD\" aria-label=\"82 스칼라 서브 쿼리 사용 시 주의사항 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>Select 절에 사용된 쿼리를 스칼라 서브 쿼리라고 한다.</li>\n<li>스칼라 서브 쿼리를 사용하는 것은 많은 경우에 있어서 나쁜 성능을 보이기 때문에 Where 조건이 분산도가 좋은 인덱스를 사용하고 전체 쿼리 결과가 소량인 경우에만 사용한다.</li>\n</ul>\n<h3 id=\"83-페이징-처리\" style=\"position:relative;\">8.3 페이징 처리<a href=\"#83-%ED%8E%98%EC%9D%B4%EC%A7%95-%EC%B2%98%EB%A6%AC\" aria-label=\"83 페이징 처리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>페이징 처리 시, 다음과 같은 이유로 테이블을 전체 범위 처리함하면 성능 저하게 발생한다.</p>\n<ul>\n<li>전체 건수/페이지 수의 표시 문제</li>\n<li>무의미한 전체 건수 표시 제거</li>\n<li>변경이 적은 목록은 전체 건수 및 페이지 수를 초기에만 생성 후 재사용</li>\n<li>Order By 이용한 목록 정렬 문제</li>\n<li>Order By 순서와 일치하는 페이징 인덱스를 생성해서 사용</li>\n<li>페이징 인덱스 컬럼 값을 페이지 이동 시 다음 키값으로 사용</li>\n<li>분산도가 좋은 필수 입력항목 부재</li>\n<li>분산도가 좋은 입력항목을 지정하고, 기본값 설정</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"9-배치-성능-개선\" style=\"position:relative;\">9. 배치 성능 개선<a href=\"#9-%EB%B0%B0%EC%B9%98-%EC%84%B1%EB%8A%A5-%EA%B0%9C%EC%84%A0\" aria-label=\"9 배치 성능 개선 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>배치는 DB에서 처리 대상을 추출하는 메인리더 부분과 프로세싱하는 부분, 처리 결과를 DB에 기록하는 부분으로 나뉜다.</li>\n</ul>\n<h3 id=\"91-전체-테이블-탐색\" style=\"position:relative;\">9.1 전체 테이블 탐색<a href=\"#91-%EC%A0%84%EC%B2%B4-%ED%85%8C%EC%9D%B4%EB%B8%94-%ED%83%90%EC%83%89\" aria-label=\"91 전체 테이블 탐색 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>메인리더가 수만 건 내외의 소량건을 조회해서 처리한다면 테이블 인덱스를 사용하는 것이 효과적이지만 수만 건 이상 조회해야 한다면 테이블 전체를 읽어서 조회하는 편이 성능이 좋은 경우가 많다.</li>\n<li>\n<p>인덱스를 사용하면 읽는 블록수가 상대적으로 적어지지만 응답시간이 늦어진다.</p>\n<ul>\n<li>그 이유는 인덱스 탐색은 인덱스를 읽어 조건에 맞는 레코드를 한 건 한건을 순차적으로 읽는 랜덤엑세스가 이뤄지는 반면 전체 테이블 탐색은 멀티블록 읽기 설정에 따라 여러 블록을 한번에 읽어 들일 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"92-파티션\" style=\"position:relative;\">9.2 파티션<a href=\"#92-%ED%8C%8C%ED%8B%B0%EC%85%98\" aria-label=\"92 파티션 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>대량 건을 조회할 때 전체 테이블 탐색이 성능이 우수하다고 하지만 사이즈가 커질 수록 부담스러운 작업이다.</li>\n<li>이 같은 상황에서 해결책으로 고려해볼 수 있는것이 파티션이다.</li>\n<li>Where 조건에 파티션의 범위를 지정한다면 전체 탐색을 하더라도 지정된 파티션 범위 내에서만 전체 탐색이 발생한다.</li>\n</ul>\n<h3 id=\"93-해시-조인\" style=\"position:relative;\">9.3 해시 조인<a href=\"#93-%ED%95%B4%EC%8B%9C-%EC%A1%B0%EC%9D%B8\" aria-label=\"93 해시 조인 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>테이블 조인에서 조회하는 건수가 소량이고 모든 테이블에 적절한 인덱스가 존재한다면 내포 조인이 가장 효과적이다.</li>\n<li>대량 건을 조회한다면 내포 조인대신 해시 조인을 사용하는 것이 성능상 유리하다.</li>\n</ul>\n<h3 id=\"95-쿼리-통합\" style=\"position:relative;\">9.5 쿼리 통합<a href=\"#95-%EC%BF%BC%EB%A6%AC-%ED%86%B5%ED%95%A9\" aria-label=\"95 쿼리 통합 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h4>9.5.1 메인리더와 건별 처리 쿼리 통합</h4>\n<ul>\n<li>메인리더에서 읽은 데이터를 기반으로 건별 처리 로직에서 부가 정보를 획득하거나 확인을 위해 추가 쿼리를 수행하는 경우가 많은데 메인리더와 통합하면 성능 개선효과가 있다.</li>\n</ul>\n<h4>9.5.2 메인리더와 Insert 통합</h4>\n<ul>\n<li>건별로 조회하해 데이터를 처리하는 것이 가장 느리다.</li>\n<li>1000건씩 Fetch 하여 집합 처리(batch)를 활용한다면 더 빠를 것 이다.</li>\n<li>마지막으로 시도해볼 수 있는 방법은 <code class=\"language-text\">Insert ... Select</code> 구문을 사용하는 것이다.</li>\n<li>사실상 애플리케이션으로 처리 데이터가 오지 않고 전부 DB 내부에서 처리하는 것 이다.</li>\n</ul>\n<h4>9.5.3 Select / Insert / Update 통합</h4>\n<ul>\n<li>오라클에서는 <code class=\"language-text\">Merge</code>를 통해 Select Insert Update 쿼리를 통합할 수 있다.</li>\n<li>Mysql에서는 <code class=\"language-text\">ON DUPLICATE KEY</code> 로 통합할 수 있다.</li>\n</ul>","frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝","date":"March 16, 2022","update":"March 16, 2022","tags":["실무로 배우는 시스템 성능 최적화"],"series":null},"fields":{"slug":"/ch7/","readingTime":{"minutes":17.8}}},"seriesList":{"edges":[{"node":{"id":"296328f9-f83a-5280-ba4d-bd4de2c4a23a","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"c9052258-da8a-5838-97d0-5affaae34156","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"eaf68b24-edef-59b5-a7f4-4e9ea41b0321","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"522e45a7-12b4-55ae-8295-4a720f58da60","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"5413888c-b834-5d0a-a576-10b33121e612","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"b7dfee63-516c-5cf7-83bd-cfe07286f825","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"a652b497-d0e9-5d72-988a-35fb96da4202","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"142b9f9f-7ca6-5376-aa9b-55bd67d46ee3","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"440239bd-9cf3-519f-86af-72f698bb3262","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"2f0b9a48-2617-5e0a-ab00-4571b7e012c7","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"60bb268c-033b-5cdd-bba3-9351aa771fb4","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"eee5ea21-1271-510f-9b52-f5c2b8e6f8ed","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"e512cc83-75e1-552a-813b-543508957e1f","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"4db40817-9881-5aea-a6d4-b7b009c1a350","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"bb9c36ac-6d3d-53ff-891c-3d0e6d56115a","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"15e07ee1-b1da-592c-97db-c67d8a458b0c","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"00a98f1e-f4b7-562e-b052-7c7bbf333a61","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"d2b050d0-1ad6-5db3-8087-46c1ef770d5d","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"39f89aa8-d521-51b6-af7e-4f25f0648182","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"8934dee6-96ba-552c-bcd6-49294d6e7cc2","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"19fdfd91-656a-5e79-9d96-1f5a12da47ca","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"acc5f56e-6968-539d-9ffc-483a26a0d5ee","fields":{"slug":"/enabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"3dcec820-a2a1-54a0-aaf6-fda09480d78d","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"4329bf0c-4a54-5d63-9354-7dd221de8490","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"b68512de-7b86-5edf-8547-d9e1103dbcf0","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"bdf354b5-bb11-5ca5-b46f-4fe625963602","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"ca70e5d9-9f49-5e98-be76-85def8989dbf","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"f4b0fec2-64a8-50c4-b32f-a4e3165b2c34","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"258fb9df-ac30-55cf-91f5-1d626b51fbc6","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"bc1f40bb-26d9-5ce5-8e40-26be0b6f4ec9","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"9edb5e98-0831-5f05-99ac-5243f5e61ed1","fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}}},{"node":{"id":"be7a2fa8-5b1e-57c0-ac68-164a29e2c50a","fields":{"slug":"/socket_option/"},"frontmatter":{"title":"Java의 Socket Option 정리"}}},{"node":{"id":"380cd3ba-df02-5eb5-bd99-dd88eee889c3","fields":{"slug":"/tomcat-connection/"},"frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?"}}},{"node":{"id":"d3f01e89-0b7e-5518-b223-4f91816fe1fb","fields":{"slug":"/spring-core-container/"},"frontmatter":{"title":"스프링으로 알아보는 IoC 컨테이너의 원리와 이해"}}},{"node":{"id":"74a04ce6-75c4-5373-8a4a-e11360c4778b","fields":{"slug":"/socket_internal/"},"frontmatter":{"title":"요청이 급증하는 상황의 Connection reset by peer 트러블 슈팅"}}},{"node":{"id":"e9743b3d-5c40-582b-ba0f-d58108c30c9a","fields":{"slug":"/mysql-transaction-lock/"},"frontmatter":{"title":"MySQL 잠금과 트랜잭션 Deep Dive"}}},{"node":{"id":"6f0905d8-70e8-531e-b3fa-a1df160991b9","fields":{"slug":"/java-synchronized/"},"frontmatter":{"title":"자바의 synchronized와 volatile"}}}]},"previous":{"fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}},"next":{"fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},"pageContext":{"id":"bb9c36ac-6d3d-53ff-891c-3d0e6d56115a","series":null,"previousPostId":"4db40817-9881-5aea-a6d4-b7b009c1a350","nextPostId":"15e07ee1-b1da-592c-97db-c67d8a458b0c"}},"staticQueryHashes":[],"slicesMap":{}}