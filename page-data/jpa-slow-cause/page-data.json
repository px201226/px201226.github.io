{"componentChunkName":"component---src-templates-post-jsx","path":"/jpa-slow-cause/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"markdownRemark":{"id":"f4b0fec2-64a8-50c4-b32f-a4e3165b2c34","excerpt":"N+1 쿼리는 무엇을 의마하나? JPA의 한계를 설명하기 위해서는 N+1 쿼리가 발생하는 원초적인 원인에 대해 이해하는 것이 필요하다. JPA를 사용하다보면 N+1 쿼리를 경험할 수 있는데, 기술적인 방법으로 N+1 쿼리를 해결하는 게시물은 많지만, 왜 이러한 쿼리가 발생하는지에 대해 정확히 설명하는 블로그는 찾기 어렵다. 본 포스팅에서는 N+1 쿼리가 …","html":"<h2 id=\"N1-쿼리는-무엇을-의마하나\" style=\"position:relative;\">N+1 쿼리는 무엇을 의마하나?<a href=\"#N1-%EC%BF%BC%EB%A6%AC%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%84-%EC%9D%98%EB%A7%88%ED%95%98%EB%82%98\" aria-label=\"N1 쿼리는 무엇을 의마하나 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>JPA의 한계를 설명하기 위해서는 N+1 쿼리가 발생하는 원초적인 원인에 대해 이해하는 것이 필요하다.<br>\nJPA를 사용하다보면 N+1 쿼리를 경험할 수 있는데, 기술적인 방법으로 N+1 쿼리를 해결하는 게시물은 많지만, 왜 이러한 쿼리가 발생하는지에 대해 정확히 설명하는 블로그는 찾기 어렵다.<br>\n본 포스팅에서는 N+1 쿼리가 발생하는 원인을 설명하고, 이로 인해 JPA가 성능상 한계에 부딪힐 수밖에 없는 이유에 대해 설명하려고 한다.</p>\n<!-- more -->\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Member</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy <span class=\"token operator\">=</span> <span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">AUTO</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> username<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@ManyToOne</span>\n    <span class=\"token annotation punctuation\">@JoinColumn</span><span class=\"token punctuation\">(</span>name <span class=\"token operator\">=</span> <span class=\"token string\">\"team_id\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Team</span> team<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Entity</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Team</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@Id</span> <span class=\"token annotation punctuation\">@GeneratedValue</span><span class=\"token punctuation\">(</span>strategy <span class=\"token operator\">=</span> <span class=\"token class-name\">GenerationType</span><span class=\"token punctuation\">.</span><span class=\"token constant\">AUTO</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">Long</span> id<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">String</span> teamName<span class=\"token punctuation\">;</span>\n\n    <span class=\"token annotation punctuation\">@OneToMany</span>\n    <span class=\"token keyword\">private</span> <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Member</span><span class=\"token punctuation\">></span></span> members<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@SpringBootTest</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">JpaTest</span><span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token annotation punctuation\">@Test</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token class-name\">Nplus1</span>테스트<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t\t<span class=\"token keyword\">final</span> <span class=\"token keyword\">var</span> teams <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select team from Team team\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token punctuation\">.</span><span class=\"token function\">getResultList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">Team</span> team <span class=\"token operator\">:</span> teams<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\tteam<span class=\"token punctuation\">.</span><span class=\"token function\">getMembers</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>member <span class=\"token operator\">-></span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>member<span class=\"token punctuation\">.</span><span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 테스트 코드를 실행시키면 team 을 조회하는 쿼리(1)와 각 team 별로 자식인 member 조회하는 쿼리(N)이 나가, 결과적으로 N+1 쿼리가 발생한다.</p>\n<p>아래는 테스트 코드를 돌렸을 때, 데이터베이스로 호출되는 SQL이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> team<span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span><span class=\"token comment\">-- (1번 쿼리) --/</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> member <span class=\"token keyword\">where</span> member<span class=\"token punctuation\">.</span>team_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span><span class=\"token comment\">-- (N 쿼리) --/</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> member <span class=\"token keyword\">where</span> member<span class=\"token punctuation\">.</span>team_id <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span><span class=\"token comment\">-- (N 쿼리) --/</span></code></pre></div>\n<p>간단한 이유로 N+1 쿼리가 발생하는 이유는 다음과 같다. member와 join 없이 team에 대해서만 select 쿼리를 날렸기 때문이다.\n처음에 (1번) 쿼리에서는 Team만 조회되었기 때문에, 연관된 테이블인 member를 찾기 위해 추가적인 쿼리가 필요하게 된다. 이로 인해 쿼리의 수가 N+1개가 되는 것이다.</p>\n<p>아래는 Native SQL로 N+1 쿼리를 발생시키는 코드다. (예시)</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">JpaTest</span> <span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token annotation punctuation\">@Test</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token function\">native_sql_Nplus1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n\t\t<span class=\"token keyword\">final</span> <span class=\"token keyword\">var</span> teams <span class=\"token operator\">=</span> jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SELECT * FROM team\"</span><span class=\"token punctuation\">,</span> teamRowMapper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">final</span> <span class=\"token class-name\">Team</span> team <span class=\"token operator\">:</span> teams<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">final</span> <span class=\"token keyword\">var</span> member <span class=\"token operator\">=</span> jdbcTemplate<span class=\"token punctuation\">.</span><span class=\"token function\">query</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SELECT * FROM member WHERE member.team_id = \"</span> <span class=\"token operator\">+</span> team<span class=\"token punctuation\">.</span><span class=\"token function\">getId</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> memberRowMapper<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t\tmember<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>m <span class=\"token operator\">-></span> <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">.</span><span class=\"token function\">getUsername</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>N+1 쿼리는 JPA 입장에서는 연관 관계 맵핑 정보를 보고 그대로 쿼리를 실행한 결과로 볼 수 있다. JPA는 객체지향적인 관점에서 데이터를 가져오기 위해 연관된 엔티티들을 필요에 따라 추가로 조회하는 것이므로, 이는 JPA의 기능을 잘 수행한 것이다.\n그러나 데이터베이스 입장에서는 N번의 호출로 인해 비효율적인 처리가 발생하였다.</p>\n<p>N+1 쿼리를 해결하기 위해 크게 두 가지 방법이 있다.</p>\n<ul>\n<li>member와 team을 join하는 방법.</li>\n<li>member를 조회할 때 중복을 제거한 team의 id 값들로 batch IN절을 사용해 테이블 각각을 조회 후, 어플리케이션에서 조립하는 방법.</li>\n</ul>\n<p>JPA에서는 N+1 쿼리를 해결하기 위해 fetch join, EntityGraph, batch size 조정 등의 방법을 제공하지만, 결국은 위의 두 가지 방법을 사용해야 한다.\n또한, N+1 쿼리는 조회뿐만 아니라 UPDATE, DELETE 쿼리에서도 발생할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Transactional</span>\n<span class=\"token annotation punctuation\">@SpringBootTest</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">JpaTest</span><span class=\"token punctuation\">{</span>\n\t\n\t<span class=\"token annotation punctuation\">@Test</span>\n\t<span class=\"token keyword\">void</span> <span class=\"token class-name\">Nplus1</span>테스트<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n\t\t<span class=\"token keyword\">final</span> <span class=\"token keyword\">var</span> teams <span class=\"token operator\">=</span> em<span class=\"token punctuation\">.</span><span class=\"token function\">createQuery</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"select team from Team team\"</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Team</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span>\n\t\t\t\t<span class=\"token punctuation\">.</span><span class=\"token function\">getResultList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Team</span> team <span class=\"token operator\">:</span> teams<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t\t  team<span class=\"token punctuation\">.</span><span class=\"token function\">setTeamName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ABC\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\t\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> team<span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span><span class=\"token comment\">-- (1번 쿼리) --/</span>\n<span class=\"token keyword\">UPDATE</span> team <span class=\"token keyword\">SET</span> team<span class=\"token punctuation\">.</span>teamName <span class=\"token operator\">=</span> <span class=\"token string\">'ABC'</span> <span class=\"token keyword\">WHERE</span> team<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span><span class=\"token comment\">-- (N 쿼리) --/</span>\n<span class=\"token keyword\">UPDATE</span> team <span class=\"token keyword\">SET</span> team<span class=\"token punctuation\">.</span>teamName <span class=\"token operator\">=</span> <span class=\"token string\">'ABC'</span> <span class=\"token keyword\">WHERE</span> team<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span><span class=\"token comment\">-- (N 쿼리) --/</span>\n<span class=\"token keyword\">UPDATE</span> team <span class=\"token keyword\">SET</span> team<span class=\"token punctuation\">.</span>teamName <span class=\"token operator\">=</span> <span class=\"token string\">'ABC'</span> <span class=\"token keyword\">WHERE</span> team<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token operator\">/</span><span class=\"token comment\">-- (N 쿼리) --/</span></code></pre></div>\n<p>이런 경우에도 쿼리 최적화가 필요하며, 모든 team 을 조회해서 teamName을 'ABC' 로 바꾸기 때문에 아래와 같은 방법으로 해결할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">UPDATE</span> team <span class=\"token keyword\">SET</span> team<span class=\"token punctuation\">.</span>teamName <span class=\"token operator\">=</span> <span class=\"token string\">'ABC'</span></code></pre></div>\n<p>특정 team 만 업데이트 하고 싶다면 아래와 같은 방법을 쓸 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">UPDATE</span> team <span class=\"token keyword\">SET</span> team<span class=\"token punctuation\">.</span>teamName <span class=\"token operator\">=</span> <span class=\"token string\">'ABC'</span> <span class=\"token keyword\">WHERE</span> team<span class=\"token punctuation\">.</span>id <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h2 id=\"관계형-데이터베이스는-집합이다\" style=\"position:relative;\">관계형 데이터베이스는 집합이다<a href=\"#%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%8A%94-%EC%A7%91%ED%95%A9%EC%9D%B4%EB%8B%A4\" aria-label=\"관계형 데이터베이스는 집합이다 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>앞에서 본 N+1 쿼리와 그것을 튜닝한 쿼리의 방식에 차이점이 보이는가?\n관계형 데이터 모델은 수학의 집합론을 기반으로 한 데이터베이스 모델로, 관계형 데이터베이스의 데이터 연산은 집합적 연산으로 이루어져 있고 이에 최적화되어 있다.\n(교집합 연산 join, 합집합 연산 union, 부분집합 연산 select 등)<br>\nN+1 쿼리를 해결하는 방법은 결국 단일 Element에 대한 연산을 여러 개 수행하는 것을 피하고, 대신 집합 연산을 활용하여 효율적으로 처리하는 것이다.\n결과적으로, JPA가 성능상 한계에 부딪힐 수 밖에 없는 이유는 JPA가 엔티티 집합을 다루는 연산에 한계가 있기 때문이라고 볼 수 있다.</p>\n<p>물론, JPQL을 사용하면 Native SQL을 사용하는 것 처럼 데이터베이스의 집합연산을 할 수 있다.<br>\nUPDATE 문의 N+1 쿼리 예제에서 JPQL로 update문을 통해 teamName을 집합적으로 변경하는 로직으로 리팩토링 하면 다음과 같은 형식일 것 이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token comment\">/*\nfinal var teams = em.createQuery(\"select team from Team team\", Team.class).getResultList();\n\nfor(Team team : teams){\n  team.setTeamName(\"ABC\");\n} */</span>\nteamRepository<span class=\"token punctuation\">.</span><span class=\"token function\">renameAllTeams</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ABC\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//renameAllTeams() 는 JPQL로 작성한 집합연산이다.</span></code></pre></div>\n<p>성능상의 문제는 해결되었지만, JPA로 객체지향적으로 작성한 원래의 코드가 사라지고,\n데이터베이스 사용에 대한 투명성도 사리지게 되었다. 이는 JPQL을 활용한 최적화된 쿼리가 Native SQL과 거의 동일한 형태로 변환되었기 때문이다.\n또한, 리팩토링된 코드는 JPQL을 네이티브 SQL로 파싱하는 과정만 추가된 것으로, Native SQL에 비해 JPQL이 가지는 장점도 거의 없다.</p>\n<h2 id=\"정리\" style=\"position:relative;\">정리<a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>결국 JPA가 성능적 한계는 집합 연산에 대한 지원이 부족하다는 것으로 요약할 수 있다.\n우리가 어노테이션을 통해 JPA 연관관계에 대한 정보를 정의하지만 이것은 단일 엔티티에 대한 맵핑 정보를 제공하는 것 이다.\n따라서, JPA는 엔티티 집합을 개별 엔티티 각각으로 처리할 수 밖에 없고, 이러한 작업은 집합론을 베이스로 한 관계형 데이터베이스에서\n처리하기에는 느릴 수 밖에 없는 구조가 나오는 것 이다.\n오히려 JPA의 방식은 Key-value 기반 스토리지에 더 적합한 방식이라고 볼 수 있다.<br>\n이러한 문제점은 객체 패러다임과 관계형 패러다임 간에 쉽게 해결할 수 없는 문제라고 본다.<br>\n지금 개발하고 있는 서비스는 엔티티의 집합적 연산을 요하는 요구사항이 많아, JPA 기술에 대한 의심이 있었는데<br>\n이러한 ORM의 한계를 인정하면서 JPA의 객체지향적인 장점과 Native SQL 접근 방식을 균형있게 쓰는 것이 좋을 것 같다.</p>","frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유","date":"July 21, 2023","update":"July 21, 2023","tags":["JPA"],"series":null},"fields":{"slug":"/jpa-slow-cause/","readingTime":{"minutes":9.11}}},"seriesList":{"edges":[{"node":{"id":"296328f9-f83a-5280-ba4d-bd4de2c4a23a","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"c9052258-da8a-5838-97d0-5affaae34156","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"eaf68b24-edef-59b5-a7f4-4e9ea41b0321","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"522e45a7-12b4-55ae-8295-4a720f58da60","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"5413888c-b834-5d0a-a576-10b33121e612","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"b7dfee63-516c-5cf7-83bd-cfe07286f825","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"a652b497-d0e9-5d72-988a-35fb96da4202","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"142b9f9f-7ca6-5376-aa9b-55bd67d46ee3","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"440239bd-9cf3-519f-86af-72f698bb3262","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"2f0b9a48-2617-5e0a-ab00-4571b7e012c7","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"60bb268c-033b-5cdd-bba3-9351aa771fb4","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"eee5ea21-1271-510f-9b52-f5c2b8e6f8ed","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"e512cc83-75e1-552a-813b-543508957e1f","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"4db40817-9881-5aea-a6d4-b7b009c1a350","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"bb9c36ac-6d3d-53ff-891c-3d0e6d56115a","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"15e07ee1-b1da-592c-97db-c67d8a458b0c","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"00a98f1e-f4b7-562e-b052-7c7bbf333a61","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"d2b050d0-1ad6-5db3-8087-46c1ef770d5d","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"39f89aa8-d521-51b6-af7e-4f25f0648182","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"8934dee6-96ba-552c-bcd6-49294d6e7cc2","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"19fdfd91-656a-5e79-9d96-1f5a12da47ca","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"acc5f56e-6968-539d-9ffc-483a26a0d5ee","fields":{"slug":"/enabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"3dcec820-a2a1-54a0-aaf6-fda09480d78d","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"4329bf0c-4a54-5d63-9354-7dd221de8490","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"b68512de-7b86-5edf-8547-d9e1103dbcf0","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"bdf354b5-bb11-5ca5-b46f-4fe625963602","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"ca70e5d9-9f49-5e98-be76-85def8989dbf","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"f4b0fec2-64a8-50c4-b32f-a4e3165b2c34","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"258fb9df-ac30-55cf-91f5-1d626b51fbc6","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"bc1f40bb-26d9-5ce5-8e40-26be0b6f4ec9","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"9edb5e98-0831-5f05-99ac-5243f5e61ed1","fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}}},{"node":{"id":"be7a2fa8-5b1e-57c0-ac68-164a29e2c50a","fields":{"slug":"/socket_option/"},"frontmatter":{"title":"Java의 Socket Option 정리"}}},{"node":{"id":"380cd3ba-df02-5eb5-bd99-dd88eee889c3","fields":{"slug":"/tomcat-connection/"},"frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?"}}},{"node":{"id":"d3f01e89-0b7e-5518-b223-4f91816fe1fb","fields":{"slug":"/spring-core-container/"},"frontmatter":{"title":"스프링으로 알아보는 IoC 컨테이너의 원리와 이해"}}},{"node":{"id":"74a04ce6-75c4-5373-8a4a-e11360c4778b","fields":{"slug":"/socket_internal/"},"frontmatter":{"title":"요청이 급증하는 상황의 Connection reset by peer 트러블 슈팅"}}},{"node":{"id":"e9743b3d-5c40-582b-ba0f-d58108c30c9a","fields":{"slug":"/mysql-transaction-lock/"},"frontmatter":{"title":"MySQL 잠금과 트랜잭션 Deep Dive"}}},{"node":{"id":"6f0905d8-70e8-531e-b3fa-a1df160991b9","fields":{"slug":"/java-synchronized/"},"frontmatter":{"title":"자바의 synchronized와 volatile"}}}]},"previous":{"fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}},"next":{"fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},"pageContext":{"id":"f4b0fec2-64a8-50c4-b32f-a4e3165b2c34","series":null,"previousPostId":"ca70e5d9-9f49-5e98-be76-85def8989dbf","nextPostId":"258fb9df-ac30-55cf-91f5-1d626b51fbc6"}},"staticQueryHashes":[],"slicesMap":{}}